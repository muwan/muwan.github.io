<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芝麻开源</title>
  <subtitle>对大海情有独钟却又怀有敬意，很懒的一个理科男。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhimakaiyuan.com/"/>
  <updated>2016-12-26T01:10:54.000Z</updated>
  <id>http://www.zhimakaiyuan.com/</id>
  
  <author>
    <name>muwan</name>
    <email>wanrumu@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(转载)细说GCD（Grand Central Dispatch）如何用</title>
    <link href="http://www.zhimakaiyuan.com/2016/12/26/GCD-and-how-to-use/"/>
    <id>http://www.zhimakaiyuan.com/2016/12/26/GCD-and-how-to-use/</id>
    <published>2016-12-26T00:50:22.000Z</published>
    <updated>2016-12-26T01:10:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。文中的Demo在这里 <a href="https://github.com/ming1016/GCDDemo" target="_blank" rel="external">https://github.com/ming1016/GCDDemo</a> 对着文章试着来调demo体会更深哦，细细嚼消化好:)<br><a id="more"></a><br>博客原文链接:<a href="https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8#gcd%E6%A6%82%E8%A6%81" target="_blank" rel="external">https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8#gcd%E6%A6%82%E8%A6%81</a></p>
<h1 id="GCD（Grand-Central-Dispatch）-介绍"><a href="#GCD（Grand-Central-Dispatch）-介绍" class="headerlink" title="GCD（Grand Central Dispatch） 介绍"></a>GCD（Grand Central Dispatch） 介绍</h1><p>GCD属于系统级的线程管理，在Dispatch queue中执行需要执行的任务性能非常的高。GCD这块已经开源，地址<a href="http://libdispatch.macosforge.org" target="_blank" rel="external">http://libdispatch.macosforge.org</a>。GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。</p>
<h2 id="GCD概要"><a href="#GCD概要" class="headerlink" title="GCD概要"></a>GCD概要</h2><ul>
<li>和operation queue一样都是基于队列的并发编程API，他们通过集中管理大家协同使用的线程池。</li>
<li>公开的5个不同队列：运行在主线程中的main queue，3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），以及一个优先级更低的后台队列Background Priority Queue（用于I/O）</li>
<li>可创建自定义队列：串行或并列队列。自定义一般放在Default Priority Queue和Main Queue里。</li>
<li>操作是在多线程上还是单线程主要是看队列的类型和执行方法，并行队列异步执行才能在多线程，并行队列同步执行就只会在主线程执行了</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>系统标准两个队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//全局队列，一个并行的队列</div><div class="line">dispatch_get_global_queue</div><div class="line">//主队列，主线程中的唯一队列，一个串行队列</div><div class="line">dispatch_get_main_queue</div></pre></td></tr></table></figure>
<ul>
<li>自定义队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//串行队列</div><div class="line">dispatch_queue_create(&quot;com.starming.serialqueue&quot;, DISPATCH_QUEUE_SERIAL)</div><div class="line">//并行队列</div><div class="line">dispatch_queue_create(&quot;com.starming.concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT)</div></pre></td></tr></table></figure>
<ul>
<li>同步异步线程创建</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//同步线程</div><div class="line">dispatch_sync(..., ^(block))</div><div class="line">//异步线程</div><div class="line">dispatch_async(..., ^(block))</div></pre></td></tr></table></figure>
<h1 id="队列（dispatch-queue）"><a href="#队列（dispatch-queue）" class="headerlink" title="队列（dispatch queue）"></a>队列（dispatch queue）</h1><ul>
<li>Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。</li>
<li>Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。</li>
<li>Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。系统提供四个全局并发队列，这四个队列有着对应的优先级，用户是不能够创建全局队列的，只能获取。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dipatch_queue_t queue;</div><div class="line">queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0);</div></pre></td></tr></table></figure>
<ul>
<li>user create queue：创建自己定义的队列，可以用dispatch_queue_create函数，函数有两个参数，第一个自定义的队列名，第二个参数是队列类型，默认NULL或者DISPATCH_QUEUE_SERIAL的是串行，参数为DISPATCH_QUEUE_CONCURRENT为并行队列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue</div><div class="line">queue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<ul>
<li>自定义队列的优先级：可以通过dipatch_queue_attr_make_with_qos_class或dispatch_set_target_queue方法设置队列的优先级</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//dipatch_queue_attr_make_with_qos_class</div><div class="line">dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, -1);</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.starming.gcddemo.qosqueue&quot;, attr);</div><div class="line"></div><div class="line">//dispatch_set_target_queue</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.starming.gcddemo.settargetqueue&quot;,NULL); //需要设置优先级的queue</div><div class="line">dispatch_queue_t referQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0); //参考优先级</div><div class="line">dispatch_set_target_queue(queue, referQueue); //设置queue和referQueue的优先级一样</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_set_target_queue：可以设置优先级，也可以设置队列层级体系，比如让多个串行和并行队列在统一一个串行队列里串行执行，如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_queue_t firstQueue = dispatch_queue_create(&quot;com.starming.gcddemo.firstqueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_queue_t secondQueue = dispatch_queue_create(&quot;com.starming.gcddemo.secondqueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">dispatch_set_target_queue(firstQueue, serialQueue);</div><div class="line">dispatch_set_target_queue(secondQueue, serialQueue);</div><div class="line"></div><div class="line">dispatch_async(firstQueue, ^&#123;</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    [NSThread sleepForTimeInterval:3.f];</div><div class="line">&#125;);</div><div class="line">dispatch_async(secondQueue, ^&#123;</div><div class="line">    NSLog(@&quot;2&quot;);</div><div class="line">    [NSThread sleepForTimeInterval:2.f];</div><div class="line">&#125;);</div><div class="line">dispatch_async(secondQueue, ^&#123;</div><div class="line">    NSLog(@&quot;3&quot;);</div><div class="line">    [NSThread sleepForTimeInterval:1.f];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="队列类型"><a href="#队列类型" class="headerlink" title="队列类型"></a>队列类型</h2><p>队列默认是串行的，如果设置改参数为NULL会按串行处理，只能执行一个单独的block，队列也可以是并行的，同一时间执行多个block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (id)init;</div><div class="line">&#123;</div><div class="line">     self = [super init];</div><div class="line">     if (self != nil) &#123;</div><div class="line">          NSString *label = [NSString stringWithFormat:@&quot;%@.isolation.%p&quot;, [self class], self];</div><div class="line">          self.isolationQueue = dispatch_queue_create([label UTF8String], 0);</div><div class="line"></div><div class="line">          label = [NSString stringWithFormat:@&quot;%@.work.%p&quot;, [self class], self];</div><div class="line">          self.workQueue = dispatch_queue_create([label UTF8String], 0);</div><div class="line">     &#125;</div><div class="line">     return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为</p>
<ul>
<li>QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。</li>
<li>QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。</li>
<li>QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。</li>
<li>QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</li>
</ul>
<p>示例：后台加载显示图片<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">     <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line">     dispatch_async(dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_USER_INITIATED</span>.value), <span class="number">0</span>)) &#123; <span class="comment">// 将工作从主线程转移到全局队列中，这是dispatch_async调用，异步提交保证调用线程会继续执行下去，这样viewDidLoad在主线程上能够更早完成，</span></div><div class="line">          <span class="keyword">let</span> overlayImage = <span class="keyword">self</span>.faceOverlayImageFromImage(<span class="keyword">self</span>.image)</div><div class="line">          dispatch_async(dispatch_get_main_queue()) &#123; <span class="comment">// 新图完成，把一个闭包加入主线程用来更新UIImageView，只有在主线程能操作UIKit。</span></div><div class="line">               <span class="keyword">self</span>.fadeInNewImage(overlayImage) <span class="comment">// 更新UI</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>何时使用何种队列类型</p>
<ul>
<li>主队列（顺序）：队列中有任务完成需要更新UI时，dispatch_after在这种类型中使用。</li>
<li>并发队列：用来执行与UI无关的后台任务，dispatch_sync放在这里，方便等待任务完成进行后续处理或和dispatch barrier同步。dispatch groups放在这里也不错。</li>
<li>自定义顺序队列：顺序执行后台任务并追踪它时。这样做同时只有一个任务在执行可以防止资源竞争。dipatch barriers解决读写锁问题的放在这里处理。dispatch groups也是放在这里。</li>
</ul>
<p>可以使用下面的方法简化QoS等级参数的写法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="type">GlobalMainQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_main_queue()</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalUserInteractiveQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_USER_INTERACTIVE</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalUserInitiatedQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_USER_INITIATED</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalUtilityQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_UTILITY</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> <span class="type">GlobalBackgroundQueue</span>: dispatch_queue_t &#123;</div><div class="line">     <span class="keyword">return</span> dispatch_get_global_queue(<span class="type">Int</span>(<span class="type">QOS_CLASS_BACKGROUND</span>.value), <span class="number">0</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用起来就是这样，易读而且容易看出在使用哪个队列</span></div><div class="line">dispatch_async(<span class="type">GlobalUserInitiatedQueue</span>) &#123;</div><div class="line">     <span class="keyword">let</span> overlayImage = <span class="keyword">self</span>.faceOverlayImageFromImage(<span class="keyword">self</span>.image)</div><div class="line">     dispatch_async(<span class="type">GlobalMainQueue</span>) &#123;</div><div class="line">          <span class="keyword">self</span>.fadeInNewImage(overlayImage)</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-once用法"><a href="#dispatch-once用法" class="headerlink" title="dispatch_once用法"></a>dispatch_once用法</h2><p>dispatch_once_t要是全局或static变量，保证dispatch_once_t只有一份实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (UIColor *)boringColor;</div><div class="line">&#123;</div><div class="line">     static UIColor *color;</div><div class="line">     //只运行一次</div><div class="line">     static dispatch_once_t onceToken;</div><div class="line">     dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">          color = [UIColor colorWithRed:0.380f green:0.376f blue:0.376f alpha:1.000f];</div><div class="line">     &#125;);</div><div class="line">     return color;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-async"><a href="#dispatch-async" class="headerlink" title="dispatch_async"></a>dispatch_async</h2><p>设计一个异步的API调用dispatch_async()，这个调用放在API的方法或函数中做。让API的使用者设置一个回调处理队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler;</div><div class="line">&#123;</div><div class="line">     dispatch_async(self.isolationQueue, ^(void)&#123;</div><div class="line">          // do actual processing here</div><div class="line">          dispatch_async(self.resultQueue, ^(void)&#123;</div><div class="line">               handler(YES);</div><div class="line">          &#125;);</div><div class="line">     &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以避免界面会被一些耗时的操作卡死，比如读取网络数据，大数据IO，还有大量数据的数据库读写，这时需要在另一个线程中处理，然后通知主线程更新界面，GCD使用起来比NSThread和NSOperation方法要简单方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//代码框架</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">     // 耗时的操作</div><div class="line">     dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">          // 更新界面</div><div class="line">     &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//下载图片的示例</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">     NSURL * url = [NSURL URLWithString:@&quot;http://avatar.csdn.net/2/C/D/1_totogo2010.jpg&quot;];</div><div class="line">     NSData * data = [[NSData alloc]initWithContentsOfURL:url];</div><div class="line">     UIImage *image = [[UIImage alloc]initWithData:data];</div><div class="line">     if (data != nil) &#123;</div><div class="line">          dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">               self.imageView.image = image;</div><div class="line">          &#125;);</div><div class="line">     &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-after延后执行"><a href="#dispatch-after延后执行" class="headerlink" title="dispatch_after延后执行"></a>dispatch_after延后执行</h2><p>dispatch_after只是延时提交block，不是延时立刻执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)foo</div><div class="line">&#123;</div><div class="line">     double delayInSeconds = 2.0;</div><div class="line">     dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC));</div><div class="line">     dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;</div><div class="line">          [self bar];</div><div class="line">     &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>范例，实现一个推迟出现弹出框提示，比如说提示用户评价等功能。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showOrHideNavPrompt</span><span class="params">()</span></span> &#123;</div><div class="line">     <span class="keyword">let</span> delayInSeconds = <span class="number">1.0</span></div><div class="line">     <span class="keyword">let</span> popTime = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>,</div><div class="line">          <span class="type">Int64</span>(delayInSeconds * <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>))) <span class="comment">// 在这里声明推迟的时间</span></div><div class="line">     dispatch_after(popTime, <span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// 等待delayInSeconds将闭包异步到主队列</span></div><div class="line">          <span class="keyword">let</span> <span class="built_in">count</span> = <span class="type">PhotoManager</span>.sharedManager.photos.<span class="built_in">count</span></div><div class="line">          <span class="keyword">if</span> <span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">               <span class="keyword">self</span>.navigationItem.prompt = <span class="literal">nil</span></div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">self</span>.navigationItem.prompt = <span class="string">"Add photos with faces to Googlyify them!"</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子中的dispatch time的参数，可以先看看函数原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta );</div></pre></td></tr></table></figure></p>
<p>第一个参数为DISPATCH_TIME_NOW表示当前。第二个参数的delta表示纳秒，一秒对应的纳秒为1000000000，系统提供了一些宏来简化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define NSEC_PER_SEC 1000000000ull //每秒有多少纳秒</div><div class="line">#define USEC_PER_SEC 1000000ull    //每秒有多少毫秒</div><div class="line">#define NSEC_PER_USEC 1000ull      //每毫秒有多少纳秒</div></pre></td></tr></table></figure></p>
<p>这样如果要表示一秒就可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);</div><div class="line">dispatch_time(DISPATCH_TIME_NOW, 1000 * USEC_PER_SEC);</div><div class="line">dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * NSEC_PER_USEC);</div></pre></td></tr></table></figure></p>
<h2 id="dispatch-barrier-async使用Barrier-Task方法Dispatch-Barrier解决多线程并发读写同一个资源发生死锁"><a href="#dispatch-barrier-async使用Barrier-Task方法Dispatch-Barrier解决多线程并发读写同一个资源发生死锁" class="headerlink" title="dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁"></a>dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁</h2><p>Dispatch Barrier确保提交的闭包是指定队列中在特定时段唯一在执行的一个。在所有先于Dispatch Barrier的任务都完成的情况下这个闭包才开始执行。轮到这个闭包时barrier会执行这个闭包并且确保队列在此过程不会执行其它任务。闭包完成后队列恢复。需要注意dispatch_barrier_async只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和dispatch_sync一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//创建队列</div><div class="line">self.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT);</div><div class="line">//改变setter</div><div class="line">- (void)setCount:(NSUInteger)count forKey:(NSString *)key</div><div class="line">&#123;</div><div class="line">     key = [key copy];</div><div class="line">     //确保所有barrier都是async异步的</div><div class="line">     dispatch_barrier_async(self.isolationQueue, ^()&#123;</div><div class="line">          if (count == 0) &#123;</div><div class="line">               [self.counts removeObjectForKey:key];</div><div class="line">          &#125; else &#123;</div><div class="line">               self.counts[key] = @(count);</div><div class="line">          &#125;</div><div class="line">     &#125;);</div><div class="line">&#125;</div><div class="line">- (void)dispatchBarrierAsyncDemo &#123;</div><div class="line">    //防止文件读写冲突，可以创建一个串行队列，操作都在这个队列中进行，没有更新数据读用并行，写用串行。</div><div class="line">    dispatch_queue_t dataQueue = dispatch_queue_create(&quot;com.starming.gcddemo.dataqueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_async(dataQueue, ^&#123;</div><div class="line">        [NSThread sleepForTimeInterval:2.f];</div><div class="line">        NSLog(@&quot;read data 1&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_async(dataQueue, ^&#123;</div><div class="line">        NSLog(@&quot;read data 2&quot;);</div><div class="line">    &#125;);</div><div class="line">    //等待前面的都完成，在执行barrier后面的</div><div class="line">    dispatch_barrier_async(dataQueue, ^&#123;</div><div class="line">        NSLog(@&quot;write data 1&quot;);</div><div class="line">        [NSThread sleepForTimeInterval:1];</div><div class="line">    &#125;);</div><div class="line">    dispatch_async(dataQueue, ^&#123;</div><div class="line">        [NSThread sleepForTimeInterval:1.f];</div><div class="line">        NSLog(@&quot;read data 3&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_async(dataQueue, ^&#123;</div><div class="line">        NSLog(@&quot;read data 4&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>swift示例<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用dispatch_queue_create初始化一个并发队列。第一个参数遵循反向DNS命名习惯，方便描述，第二个参数是指出是并发还是顺序。</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> concurrentPhotoQueue = dispatch_queue_create(</div><div class="line"><span class="string">"com.raywenderlich.GooglyPuff.photoQueue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addPhoto</span><span class="params">(photo: Photo)</span></span> &#123;</div><div class="line">     dispatch_barrier_async(concurrentPhotoQueue) &#123; <span class="comment">// 将写操作加入到自定义的队列。开始执行时这个就是队列中唯一的一个在执行的任务。</span></div><div class="line">          <span class="keyword">self</span>._photos.append(photo) <span class="comment">// barrier能够保障不会和其他任务同时进行。</span></div><div class="line">          dispatch_async(<span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// 涉及到UI所以这个通知应该在主线程中，所以分派另一个异步任务到主队列中。</span></div><div class="line">               <span class="keyword">self</span>.postContentAddedNotification()</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//上面是解决了写可能发生死锁，下面是使用dispatch_sync解决读时可能会发生的死锁。</span></div><div class="line"><span class="keyword">var</span> photos: [<span class="type">Photo</span>] &#123;</div><div class="line">     <span class="keyword">var</span> photosCopy: [<span class="type">Photo</span>]!</div><div class="line">     dispatch_sync(concurrentPhotoQueue) &#123; <span class="comment">// 同步调度到concurrentPhotoQueue队列执行读操作</span></div><div class="line">          photosCopy = <span class="keyword">self</span>._photos <span class="comment">// 保存</span></div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> photosCopy</div><div class="line">&#125;</div><div class="line"><span class="comment">//这样读写问题都解决了。</span></div></pre></td></tr></table></figure></p>
<p>都用异步处理避免死锁，异步的缺点在于调试不方便，但是比起同步容易产生死锁这个副作用还算小的。</p>
<h2 id="dispatch-apply进行快速迭代"><a href="#dispatch-apply进行快速迭代" class="headerlink" title="dispatch_apply进行快速迭代"></a>dispatch_apply进行快速迭代</h2><p>类似for循环，但是在并发队列的情况下dispatch_apply会并发执行block任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">for (size_t y = 0; y &lt; height; ++y) &#123;</div><div class="line">     for (size_t x = 0; x &lt; width; ++x) &#123;</div><div class="line">          // Do something with x and y here</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">//因为可以并行执行，所以使用dispatch_apply可以运行的更快</div><div class="line">- (void)dispatchApplyDemo &#123;</div><div class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_apply(10, concurrentQueue, ^(size_t i) &#123;</div><div class="line">        NSLog(@&quot;%zu&quot;,i);</div><div class="line">    &#125;);</div><div class="line">    NSLog(@&quot;The end&quot;); //这里有个需要注意的是，dispatch_apply这个是会阻塞主线程的。这个log打印会在dispatch_apply都结束后才开始执行</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>dispatch_apply能避免线程爆炸，因为GCD会管理并发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)dealWiththreadWithMaybeExplode:(BOOL)explode &#123;</div><div class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    if (explode) &#123;</div><div class="line">        //有问题的情况，可能会死锁</div><div class="line">        for (int i = 0; i &lt; 999 ; i++) &#123;</div><div class="line">            dispatch_async(concurrentQueue, ^&#123;</div><div class="line">                NSLog(@&quot;wrong %d&quot;,i);</div><div class="line">                //do something hard</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        //会优化很多，能够利用GCD管理</div><div class="line">        dispatch_apply(999, concurrentQueue, ^(size_t i)&#123;</div><div class="line">            NSLog(@&quot;correct %zu&quot;,i);</div><div class="line">            //do something hard</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">     <span class="keyword">var</span> downloadGroup = dispatch_group_create()</div><div class="line">     <span class="keyword">let</span> addresses = [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">          <span class="type">SuccessKidURLString</span>,</div><div class="line">          <span class="type">LotsOfFacesURLString</span>]</div><div class="line"></div><div class="line">     dispatch_apply(<span class="type">UInt</span>(addresses.<span class="built_in">count</span>), <span class="type">GlobalUserInitiatedQueue</span>) &#123;</div><div class="line">          i <span class="keyword">in</span></div><div class="line">          <span class="keyword">let</span> index = <span class="type">Int</span>(i)</div><div class="line">          <span class="keyword">let</span> address = addresses[index]</div><div class="line">          <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">          dispatch_group_enter(downloadGroup)</div><div class="line">          <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">               image, error <span class="keyword">in</span></div><div class="line">               <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                    storedError = error</div><div class="line">               &#125;</div><div class="line">               dispatch_group_leave(downloadGroup)</div><div class="line">          &#125;</div><div class="line">          <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123;</div><div class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</div><div class="line">               completion(error: storedError)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Block组合Dispatch-groups"><a href="#Block组合Dispatch-groups" class="headerlink" title="Block组合Dispatch_groups"></a>Block组合Dispatch_groups</h2><p>dispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。</p>
<p>当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。</p>
<p>第一种使用dispatch_group_wait的swift的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     dispatch_async(<span class="type">GlobalUserInitiatedQueue</span>) &#123; <span class="comment">// 因为dispatch_group_wait会租塞当前进程，所以要使用dispatch_async将整个方法要放到后台队列才能够保证主线程不被阻塞</span></div><div class="line">          <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">          <span class="keyword">var</span> downloadGroup = dispatch_group_create() <span class="comment">// 创建一个dispatch group</span></div><div class="line"></div><div class="line">          <span class="keyword">for</span> address <span class="keyword">in</span> [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">               <span class="type">SuccessKidURLString</span>,</div><div class="line">               <span class="type">LotsOfFacesURLString</span>]</div><div class="line">          &#123;</div><div class="line">               <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">               dispatch_group_enter(downloadGroup) <span class="comment">// dispatch_group_enter是通知dispatch group任务开始了，dispatch_group_enter和dispatch_group_leave是成对调用，不然程序就崩溃了。</span></div><div class="line">               <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">                    image, error <span class="keyword">in</span></div><div class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                         storedError = error</div><div class="line">                    &#125;</div><div class="line">                    dispatch_group_leave(downloadGroup) <span class="comment">// 保持和dispatch_group_enter配对。通知任务已经完成</span></div><div class="line">               &#125;</div><div class="line">               <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          dispatch_group_wait(downloadGroup, <span class="type">DISPATCH_TIME_FOREVER</span>) <span class="comment">// dispatch_group_wait等待所有任务都完成直到超时。如果任务完成前就超时了，函数会返回一个非零值，可以通过返回值判断是否超时。也可以用DISPATCH_TIME_FOREVER表示一直等。</span></div><div class="line">          dispatch_async(<span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// 这里可以保证所有图片任务都完成，然后在main queue里加入完成后要处理的闭包，会在main queue里执行。</span></div><div class="line">               <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123; <span class="comment">// 执行闭包内容</span></div><div class="line">                    completion(error: storedError)</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>oc例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)dispatchGroupWaitDemo &#123;</div><div class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    //在group中添加队列的block</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        [NSThread sleepForTimeInterval:2.f];</div><div class="line">        NSLog(@&quot;1&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        NSLog(@&quot;2&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line">    NSLog(@&quot;go on&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二种使用dispatch_group_notify的swift的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     <span class="comment">// 不用加dispatch_async，因为没有阻塞主进程</span></div><div class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">     <span class="keyword">var</span> downloadGroup = dispatch_group_create()</div><div class="line"></div><div class="line">     <span class="keyword">for</span> address <span class="keyword">in</span> [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">          <span class="type">SuccessKidURLString</span>,</div><div class="line">          <span class="type">LotsOfFacesURLString</span>]</div><div class="line">     &#123;</div><div class="line">          <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">          dispatch_group_enter(downloadGroup)</div><div class="line">          <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">               image, error <span class="keyword">in</span></div><div class="line">               <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                    storedError = error</div><div class="line">               &#125;</div><div class="line">               dispatch_group_leave(downloadGroup)</div><div class="line">          &#125;</div><div class="line">          <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123; <span class="comment">// dispatch_group_notify和dispatch_group_wait的区别就是是异步执行闭包的，当dispatch groups中没有剩余的任务时闭包才执行。这里是指明在主队列中执行。</span></div><div class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</div><div class="line">               completion(error: storedError)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>oc例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">//dispatch_group_notify</div><div class="line">- (void)dispatchGroupNotifyDemo &#123;</div><div class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        NSLog(@&quot;1&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        NSLog(@&quot;2&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;end&quot;);</div><div class="line">    &#125;);</div><div class="line">    NSLog(@&quot;can continue&quot;);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//dispatch_group_wait</div><div class="line">- (void)dispatchGroupWaitDemo &#123;</div><div class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    //在group中添加队列的block</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        [NSThread sleepForTimeInterval:2.f];</div><div class="line">        NSLog(@&quot;1&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</div><div class="line">        NSLog(@&quot;2&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line">    NSLog(@&quot;can continue&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如何对现有API使用dispatch_group_t<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//给Core Data的-performBlock:添加groups。组合完成任务后使用dispatch_group_notify来运行一个block即可。</div><div class="line">- (void)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block</div><div class="line">&#123;</div><div class="line">     if (group == NULL) &#123;</div><div class="line">          [self performBlock:block];</div><div class="line">     &#125; else &#123;</div><div class="line">          dispatch_group_enter(group);</div><div class="line">          [self performBlock:^()&#123;</div><div class="line">               block();</div><div class="line">               dispatch_group_leave(group);</div><div class="line">          &#125;];</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//NSURLConnection也可以这样做</div><div class="line">+ (void)withGroup:(dispatch_group_t)group</div><div class="line">     sendAsynchronousRequest:(NSURLRequest *)request</div><div class="line">     queue:(NSOperationQueue *)queue</div><div class="line">     completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler</div><div class="line">&#123;</div><div class="line">     if (group == NULL) &#123;</div><div class="line">          [self sendAsynchronousRequest:request</div><div class="line">               queue:queue</div><div class="line">               completionHandler:handler];</div><div class="line">     &#125; else &#123;</div><div class="line">          dispatch_group_enter(group);</div><div class="line">          [self sendAsynchronousRequest:request</div><div class="line">                    queue:queue</div><div class="line">                    completionHandler:^(NSURLResponse *response, NSData *data, NSError *error)&#123;</div><div class="line">               handler(response, data, error);</div><div class="line">               dispatch_group_leave(group);</div><div class="line">          &#125;];</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意事项</p>
<ul>
<li>dispatch_group_async等价于dispatch_group_enter() 和 dispatch_group_leave()的组合。</li>
<li>dispatch_group_enter() 必须运行在 dispatch_group_leave() 之前。</li>
<li>dispatch_group_enter() 和 dispatch_group_leave() 需要成对出现的</li>
</ul>
<h2 id="Dispatch-Block"><a href="#Dispatch-Block" class="headerlink" title="Dispatch Block"></a>Dispatch Block</h2><p>队列执行任务都是block的方式，</p>
<ul>
<li>创建block</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)createDispatchBlock &#123;</div><div class="line">    //normal way</div><div class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    dispatch_block_t block = dispatch_block_create(0, ^&#123;</div><div class="line">        NSLog(@&quot;run block&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_async(concurrentQueue, block);</div><div class="line"></div><div class="line">    //QOS way</div><div class="line">    dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INITIATED, -1, ^&#123;</div><div class="line">        NSLog(@&quot;run qos block&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_async(concurrentQueue, qosBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_wait：可以根据dispatch block来设置等待时间，参数DISPATCH_TIME_FOREVER会一直等待block结束</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)dispatchBlockWaitDemo &#123;</div><div class="line">    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_block_t block = dispatch_block_create(0, ^&#123;</div><div class="line">        NSLog(@&quot;star&quot;);</div><div class="line">        [NSThread sleepForTimeInterval:5.f];</div><div class="line">        NSLog(@&quot;end&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_async(serialQueue, block);</div><div class="line">    //设置DISPATCH_TIME_FOREVER会一直等到前面任务都完成</div><div class="line">    dispatch_block_wait(block, DISPATCH_TIME_FOREVER);</div><div class="line">    NSLog(@&quot;ok, now can go on&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_notify：可以监视指定dispatch block结束，然后再加入一个block到队列中。三个参数分别为，第一个是需要监视的block，第二个参数是需要提交执行的队列，第三个是待加入到队列中的block</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)dispatchBlockNotifyDemo &#123;</div><div class="line">    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_block_t firstBlock = dispatch_block_create(0, ^&#123;</div><div class="line">        NSLog(@&quot;first block start&quot;);</div><div class="line">        [NSThread sleepForTimeInterval:2.f];</div><div class="line">        NSLog(@&quot;first block end&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_async(serialQueue, firstBlock);</div><div class="line">    dispatch_block_t secondBlock = dispatch_block_create(0, ^&#123;</div><div class="line">        NSLog(@&quot;second block run&quot;);</div><div class="line">    &#125;);</div><div class="line">    //first block执行完才在serial queue中执行second block</div><div class="line">    dispatch_block_notify(firstBlock, serialQueue, secondBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>dispatch_block_cancel：iOS8后GCD支持对dispatch block的取消</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)dispatchBlockCancelDemo &#123;</div><div class="line">    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    dispatch_block_t firstBlock = dispatch_block_create(0, ^&#123;</div><div class="line">        NSLog(@&quot;first block start&quot;);</div><div class="line">        [NSThread sleepForTimeInterval:2.f];</div><div class="line">        NSLog(@&quot;first block end&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_block_t secondBlock = dispatch_block_create(0, ^&#123;</div><div class="line">        NSLog(@&quot;second block run&quot;);</div><div class="line">    &#125;);</div><div class="line">    dispatch_async(serialQueue, firstBlock);</div><div class="line">    dispatch_async(serialQueue, secondBlock);</div><div class="line">    //取消secondBlock</div><div class="line">    dispatch_block_cancel(secondBlock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用dispatch-block-object（调度块）在任务执行前进行取消"><a href="#使用dispatch-block-object（调度块）在任务执行前进行取消" class="headerlink" title="使用dispatch block object（调度块）在任务执行前进行取消"></a>使用dispatch block object（调度块）在任务执行前进行取消</h2><p>dispatch block object可以为队列中的对象设置<br>示例，下载图片中途进行取消<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadPhotosWithCompletion</span><span class="params">(completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</div><div class="line">     <span class="keyword">var</span> storedError: <span class="type">NSError</span>!</div><div class="line">     <span class="keyword">let</span> downloadGroup = dispatch_group_create()</div><div class="line">     <span class="keyword">var</span> addresses = [<span class="type">OverlyAttachedGirlfriendURLString</span>,</div><div class="line">          <span class="type">SuccessKidURLString</span>,</div><div class="line">          <span class="type">LotsOfFacesURLString</span>]</div><div class="line">     addresses += addresses + addresses <span class="comment">// 扩展address数组，复制3份</span></div><div class="line">     <span class="keyword">var</span> blocks: [dispatch_block_t] = [] <span class="comment">// 一个保存block的数组</span></div><div class="line"></div><div class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; addresses.<span class="built_in">count</span> &#123;</div><div class="line">          dispatch_group_enter(downloadGroup)</div><div class="line">          <span class="keyword">let</span> block = dispatch_block_create(<span class="type">DISPATCH_BLOCK_INHERIT_QOS_CLASS</span>) &#123; <span class="comment">// 创建一个block，block的标志是DISPATCH_BLOCK_INHERIT_QOS_CLASS</span></div><div class="line">               <span class="keyword">let</span> index = <span class="type">Int</span>(i)</div><div class="line">               <span class="keyword">let</span> address = addresses[index]</div><div class="line">               <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: address)</div><div class="line">               <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123;</div><div class="line">                    image, error <span class="keyword">in</span></div><div class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</div><div class="line">                         storedError = error</div><div class="line">                    &#125;</div><div class="line">                    dispatch_group_leave(downloadGroup)</div><div class="line">               &#125;</div><div class="line">               <span class="type">PhotoManager</span>.sharedManager.addPhoto(photo)</div><div class="line">          &#125;</div><div class="line">          blocks.append(block)</div><div class="line">          dispatch_async(<span class="type">GlobalMainQueue</span>, block) <span class="comment">// 把这个block放到GlobalMainQueue上异步调用。因为全局队列是一个顺序队列所以方便取消对象block，同时可以保证下载任务在downloadPhotosWithCompletion返回后才开始执行。</span></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">for</span> block <span class="keyword">in</span> blocks[<span class="number">3</span> ..&lt; blocks.<span class="built_in">count</span>] &#123;</div><div class="line">          <span class="keyword">let</span> cancel = arc4random_uniform(<span class="number">2</span>) <span class="comment">// 随机返回一个整数，会返回0或1</span></div><div class="line">          <span class="keyword">if</span> cancel == <span class="number">1</span> &#123;</div><div class="line">               dispatch_block_cancel(block) <span class="comment">// 如果是1就取消block，这个只能发生在block还在队列中并没有开始的情况下。因为把block已经放到了GlobalMainQueue中，所以这个地方会先执行，执行完了才会执行block。</span></div><div class="line">               dispatch_group_leave(downloadGroup) <span class="comment">// 因为已经dispatch_group_enter了，所以取消时也要将其都leave掉。</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dispatch_group_notify(downloadGroup, <span class="type">GlobalMainQueue</span>) &#123;</div><div class="line">          <span class="keyword">if</span> <span class="keyword">let</span> completion = completion &#123;</div><div class="line">               completion(error: storedError)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Dispatch-IO-文件操作"><a href="#Dispatch-IO-文件操作" class="headerlink" title="Dispatch IO 文件操作"></a>Dispatch IO 文件操作</h2><p>dispatch io读取文件的方式类似于下面的方式，多个线程去读取文件的切片数据，对于大的数据文件这样会比单线程要快很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_async(queue,^&#123;/*read 0-99 bytes*/&#125;);</div><div class="line">dispatch_async(queue,^&#123;/*read 100-199 bytes*/&#125;);</div><div class="line">dispatch_async(queue,^&#123;/*read 200-299 bytes*/&#125;);</div></pre></td></tr></table></figure></p>
<ul>
<li>dispatch_io_create：创建dispatch io</li>
<li>dispatch_io_set_low_water：指定切割文件大小</li>
<li>dispatch_io_read：读取切割的文件然后合并。</li>
</ul>
<p>苹果系统日志API里用到了这个技术，可以在这里查看：<a href="https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c" target="_blank" rel="external">https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">pipe_q = dispatch_queue_create(&quot;PipeQ&quot;, NULL);</div><div class="line">//创建</div><div class="line">pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, pipe_q, ^(int err)&#123;</div><div class="line">    close(fd);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">*out_fd = fdpair[1];</div><div class="line">//设置切割大小</div><div class="line">dispatch_io_set_low_water(pipe_channel, SIZE_MAX);</div><div class="line"></div><div class="line">dispatch_io_read(pipe_channel, 0, SIZE_MAX, pipe_q, ^(bool done, dispatch_data_t pipedata, int err)&#123;</div><div class="line">    if (err == 0)</div><div class="line">    &#123;</div><div class="line">        size_t len = dispatch_data_get_size(pipedata);</div><div class="line">        if (len &gt; 0)</div><div class="line">        &#123;</div><div class="line">            //对每次切块数据的处理</div><div class="line">            const char *bytes = NULL;</div><div class="line">            char *encoded;</div><div class="line">            uint32_t eval;</div><div class="line"></div><div class="line">            dispatch_data_t md = dispatch_data_create_map(pipedata, (const void **)&amp;bytes, &amp;len);</div><div class="line">            encoded = asl_core_encode_buffer(bytes, len);</div><div class="line">            asl_msg_set_key_val(aux, ASL_KEY_AUX_DATA, encoded);</div><div class="line">            free(encoded);</div><div class="line">            eval = _asl_evaluate_send(NULL, (aslmsg)aux, -1);</div><div class="line">            _asl_send_message(NULL, eval, aux, NULL);</div><div class="line">            asl_msg_release(aux);</div><div class="line">            dispatch_release(md);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (done)</div><div class="line">    &#123;</div><div class="line">        //semaphore +1使得不需要再等待继续执行下去。</div><div class="line">        dispatch_semaphore_signal(sem);</div><div class="line">        dispatch_release(pipe_channel);</div><div class="line">        dispatch_release(pipe_q);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Dispatch-Source-用GCD监视进程"><a href="#Dispatch-Source-用GCD监视进程" class="headerlink" title="Dispatch Source 用GCD监视进程"></a>Dispatch Source 用GCD监视进程</h2><p>Dispatch Source用于监听系统的底层对象，比如文件描述符，Mach端口，信号量等。主要处理的事件如下表</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td style="text-align:left">数据增加</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td style="text-align:left">数据OR</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td style="text-align:left">Mach端口发送</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td style="text-align:left">Mach端口接收</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_MEMORYPRESSURE</td>
<td style="text-align:left">内存情况</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_PROC</td>
<td style="text-align:left">进程事件</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_READ</td>
<td style="text-align:left">读数据</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td style="text-align:left">信号</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_TIMER</td>
<td style="text-align:left">定时器</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_VNODE</td>
<td style="text-align:left">文件系统变化</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_SOURCE_TYPE_WRITE</td>
<td style="text-align:left">文件写入</td>
</tr>
</tbody>
</table>
<p>方法</p>
<ul>
<li>dispatch_source_create：创建dispatch source，创建后会处于挂起状态进行事件接收，需要设置事件处理handler进行事件处理。</li>
<li>dispatch_source_set_event_handler：设置事件处理handler</li>
<li>dispatch_source_set_cancel_handler：事件取消handler，就是在dispatch source释放前做些清理的事。</li>
<li>dispatch_source_cancel：关闭dispatch source，设置的事件处理handler不会被执行，已经执行的事件handler不会取消。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSRunningApplication *mail = [NSRunningApplication runningApplicationsWithBundleIdentifier:@&quot;com.apple.mail&quot;];</div><div class="line">if (mail == nil) &#123;</div><div class="line">     return;</div><div class="line">&#125;</div><div class="line">pid_t const pid = mail.processIdentifier;</div><div class="line">self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(self.source, ^()&#123;</div><div class="line">     NSLog(@&quot;Mail quit.&quot;);</div><div class="line">&#125;);</div><div class="line">//在事件源传到你的事件处理前需要调用dispatch_resume()这个方法</div><div class="line">dispatch_resume(self.source);</div></pre></td></tr></table></figure>
<p>监视文件夹内文件变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">NSURL *directoryURL; // assume this is set to a directory</div><div class="line">int const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);</div><div class="line">if (fd &lt; 0) &#123;</div><div class="line">     char buffer[80];</div><div class="line">     strerror_r(errno, buffer, sizeof(buffer));</div><div class="line">     NSLog(@&quot;Unable to open \&quot;%@\&quot;: %s (%d)&quot;, [directoryURL path], buffer, errno);</div><div class="line">     return;</div><div class="line">&#125;</div><div class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,</div><div class="line">DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(source, ^()&#123;</div><div class="line">     unsigned long const data = dispatch_source_get_data(source);</div><div class="line">     if (data &amp; DISPATCH_VNODE_WRITE) &#123;</div><div class="line">          NSLog(@&quot;The directory changed.&quot;);</div><div class="line">     &#125;</div><div class="line">     if (data &amp; DISPATCH_VNODE_DELETE) &#123;</div><div class="line">          NSLog(@&quot;The directory has been deleted.&quot;);</div><div class="line">     &#125;</div><div class="line">&#125;);</div><div class="line">dispatch_source_set_cancel_handler(source, ^()&#123;</div><div class="line">     close(fd);</div><div class="line">&#125;);</div><div class="line">self.source = source;</div><div class="line">dispatch_resume(self.source);</div><div class="line">//还要注意需要用DISPATCH_VNODE_DELETE 去检查监视的文件或文件夹是否被删除，如果删除了就停止监听</div></pre></td></tr></table></figure></p>
<p>NSTimer在主线程的runloop里会在runloop切换其它模式时停止，这时就需要手动在子线程开启一个模式为NSRunLoopCommonModes的runloop，如果不想开启一个新的runloop可以用不跟runloop关联的dispatch source timer，如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,0, 0, DISPATCH_TARGET_QUEUE_DEFAULT);</div><div class="line">dispatch_source_set_event_handler(source, ^()&#123;</div><div class="line">     NSLog(@&quot;Time flies.&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_time_t start</div><div class="line">dispatch_source_set_timer(source, DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC,100ull * NSEC_PER_MSEC);</div><div class="line">self.source = source;</div><div class="line">dispatch_resume(self.source);</div></pre></td></tr></table></figure></p>
<h2 id="Dispatch-Semaphore和的介绍"><a href="#Dispatch-Semaphore和的介绍" class="headerlink" title="Dispatch Semaphore和的介绍"></a>Dispatch Semaphore和的介绍</h2><p>另外一种保证同步的方法。使用dispatch_semaphore_signal加1dispatch_semaphore_wait减1，为0时等待的设置方式来达到线程同步的目的和同步锁一样能够解决资源抢占的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//dispatch semaphore</div><div class="line">- (void)dispatchSemaphoreDemo &#123;</div><div class="line">    //创建semaphore</div><div class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">        NSLog(@&quot;start&quot;);</div><div class="line">        [NSThread sleepForTimeInterval:1.f];</div><div class="line">        NSLog(@&quot;semaphore +1&quot;);</div><div class="line">        dispatch_semaphore_signal(semaphore); //+1 semaphore</div><div class="line">    &#125;);</div><div class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">    NSLog(@&quot;continue&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>这里简单介绍下iOS中常用的各种锁和他们的性能。</p>
<ul>
<li>NSRecursiveLock：递归锁，可以在一个线程中反复获取锁不会造成死锁，这个过程会记录获取锁和释放锁的次数来达到何时释放的作用。</li>
<li>NSDistributedLock：分布锁，基于文件方式的锁机制，可以跨进程访问。</li>
<li>NSConditionLock：条件锁，用户定义条件，确保一个线程可以获取满足一定条件的锁。因为线程间竞争会涉及到条件锁检测，系统调用上下切换频繁导致耗时是几个锁里最长的。</li>
<li>OSSpinLock：自旋锁，不进入内核，减少上下文切换，性能最高，但抢占多时会占用较多cpu，好点多，这时使用pthread_mutex较好。</li>
<li>pthread_mutex_t：同步锁基于C语言，底层api性能高，使用方法和其它的类似。</li>
<li>@synchronized：更加简单。</li>
</ul>
<h2 id="dispatch-suspend和dispatch-resume挂起和恢复队列"><a href="#dispatch-suspend和dispatch-resume挂起和恢复队列" class="headerlink" title="dispatch_suspend和dispatch_resume挂起和恢复队列"></a>dispatch_suspend和dispatch_resume挂起和恢复队列</h2><p>dispatch_suspend这里挂起不会暂停正在执行的block，只是能够暂停还没执行的block。</p>
<h2 id="dispatch-set-context和dispatch-get-context"><a href="#dispatch-set-context和dispatch-get-context" class="headerlink" title="dispatch_set_context和dispatch_get_context"></a>dispatch_set_context和dispatch_get_context</h2><h2 id="GCD深入操作"><a href="#GCD深入操作" class="headerlink" title="GCD深入操作"></a>GCD深入操作</h2><ul>
<li>缓冲区：dispatch_data_t基于零碎的内存区域，使用dispatch_data_apply来遍历，还可以用dispatch_data_create_subrange来创建一个不做任何拷贝的子区域</li>
<li>I/O调度：使用GCD提供的dispatch_io_read，dispatch_io_write和dispatch_io_close</li>
<li>测试：使用dispatch_benchmark小工具</li>
<li>原子操作： libkern/OSAtomic.h里可以查看那些函数，用于底层多线程编程。</li>
</ul>
<h2 id="GCD死锁"><a href="#GCD死锁" class="headerlink" title="GCD死锁"></a>GCD死锁</h2><p>当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">- (void)deadLockCase1 &#123;</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    //主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。</div><div class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;2&quot;);</div><div class="line">    &#125;);</div><div class="line">    NSLog(@&quot;3&quot;);</div><div class="line">&#125;</div><div class="line">- (void)deadLockCase2 &#123;</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    //3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行</div><div class="line">    dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</div><div class="line">        NSLog(@&quot;2&quot;);</div><div class="line">    &#125;);</div><div class="line">    NSLog(@&quot;3&quot;);</div><div class="line">&#125;</div><div class="line">- (void)deadLockCase3 &#123;</div><div class="line">    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    dispatch_async(serialQueue, ^&#123;</div><div class="line">        NSLog(@&quot;2&quot;);</div><div class="line">        //串行队列里面同步一个串行队列就会死锁</div><div class="line">        dispatch_sync(serialQueue, ^&#123;</div><div class="line">            NSLog(@&quot;3&quot;);</div><div class="line">        &#125;);</div><div class="line">        NSLog(@&quot;4&quot;);</div><div class="line">    &#125;);</div><div class="line">    NSLog(@&quot;5&quot;);</div><div class="line">&#125;</div><div class="line">- (void)deadLockCase4 &#123;</div><div class="line">    NSLog(@&quot;1&quot;);</div><div class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">        NSLog(@&quot;2&quot;);</div><div class="line">        //将同步的串行队列放到另外一个线程就能够解决</div><div class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class="line">            NSLog(@&quot;3&quot;);</div><div class="line">        &#125;);</div><div class="line">        NSLog(@&quot;4&quot;);</div><div class="line">    &#125;);</div><div class="line">    NSLog(@&quot;5&quot;);</div><div class="line">&#125;</div><div class="line">- (void)deadLockCase5 &#123;</div><div class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">        NSLog(@&quot;1&quot;);</div><div class="line">        //回到主线程发现死循环后面就没法执行了</div><div class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class="line">            NSLog(@&quot;2&quot;);</div><div class="line">        &#125;);</div><div class="line">        NSLog(@&quot;3&quot;);</div><div class="line">    &#125;);</div><div class="line">    NSLog(@&quot;4&quot;);</div><div class="line">    //死循环</div><div class="line">    while (1) &#123;</div><div class="line">        //</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="GCD实际使用"><a href="#GCD实际使用" class="headerlink" title="GCD实际使用"></a>GCD实际使用</h1><h2 id="FMDB如何使用dispatch-queue-set-specific和dispatch-get-specific来防止死锁"><a href="#FMDB如何使用dispatch-queue-set-specific和dispatch-get-specific来防止死锁" class="headerlink" title="FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁"></a>FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁</h2><p>作用类似objc_setAssociatedObject跟objc_getAssociatedObject<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static const void * const kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;</div><div class="line">//创建串行队列，所有数据库的操作都在这个队列里</div><div class="line">_queue = dispatch_queue_create([[NSString stringWithFormat:@&quot;fmdb.%@&quot;, self] UTF8String], NULL);</div><div class="line">//标记队列</div><div class="line">dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);</div><div class="line"></div><div class="line">//检查是否是同一个队列来避免死锁的方法</div><div class="line">- (void)inDatabase:(void (^)(FMDatabase *db))block &#123;</div><div class="line">    FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);</div><div class="line">    assert(currentSyncQueue != self &amp;&amp; &quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="iOS系统版本新特性"><a href="#iOS系统版本新特性" class="headerlink" title="iOS系统版本新特性"></a>iOS系统版本新特性</h1><h2 id="iOS8"><a href="#iOS8" class="headerlink" title="iOS8"></a>iOS8</h2><p>iOS8新加了一个功能叫Quality of Service(QoS)，里面提供了一下几个更容易理解的枚举名来使用user interactive，user initiated，utility和background。下面的表做了对比</p>
<table>
<thead>
<tr>
<th style="text-align:left">Global queue</th>
<th style="text-align:left">Corresponding QoS class</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Main thread</td>
<td style="text-align:left">NSQualityOfServiceUserInteractive</td>
<td style="text-align:left">UI相关，交互等</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_HIGH</td>
<td style="text-align:left">NSQualityOfServiceUserInitiated</td>
<td style="text-align:left">用户发起需要马上得到结果进行后续任务</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_DEFAULT</td>
<td style="text-align:left">NSQualityOfServiceDefault</td>
<td style="text-align:left">默认的不应该使用这个设置任务</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_LOW</td>
<td style="text-align:left">NSQualityOfServiceUtility</td>
<td style="text-align:left">花费时间稍多比如下载，需要几秒或几分钟的</td>
</tr>
<tr>
<td style="text-align:left">DISPATCH_QUEUE_PRIORITY_BACKGROUND</td>
<td style="text-align:left">NSQualityOfServiceBackground</td>
<td style="text-align:left">不可见在后台的操作可能需要好几分钟甚至几小时的</td>
</tr>
</tbody>
</table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="WWDC"><a href="#WWDC" class="headerlink" title="WWDC"></a>WWDC</h2><ul>
<li>Building Responsive and Efficient Apps with GCD：<a href="https://developer.apple.com/videos/play/wwdc2015-718/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2015-718/</a></li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li>官方文档：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/" target="_blank" rel="external">https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。文中的Demo在这里 &lt;a href=&quot;https://github.com/ming1016/GCDDemo&quot;&gt;https://github.com/ming1016/GCDDemo&lt;/a&gt; 对着文章试着来调demo体会更深哦，细细嚼消化好:)&lt;br&gt;
    
    </summary>
    
    
      <category term="转载" scheme="http://www.zhimakaiyuan.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="iOS" scheme="http://www.zhimakaiyuan.com/tags/iOS/"/>
    
      <category term="笔记" scheme="http://www.zhimakaiyuan.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>用Let&#39;s encrypt 免费给自己的博客加上https之小白版</title>
    <link href="http://www.zhimakaiyuan.com/2016/12/17/https-for-lets-encrypt/"/>
    <id>http://www.zhimakaiyuan.com/2016/12/17/https-for-lets-encrypt/</id>
    <published>2016-12-17T05:47:56.000Z</published>
    <updated>2016-12-17T05:50:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司任务不是很重，适配iOS 10 ATS 已经成为了项目这一个月的任务，杨老大负责任的把这个重担一个人扛下了，因此我等小民就只能自己去研究了，于是就寻思着给自己的博客加上ssl验证，有个小绿锁🔒 看起来确实是舒坦很多。在这里就记录下全过程。<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HTTPS目前已经成为各大主流网站的标配，未来必将成为一种趋势，很多个人博客现在也都加入了HTTPS的阵营。HTTPS好处多多，可以防止各种攻击劫持，运营商广告植入，客户传输信息泄露等问题。为了让HTTPS能够全面普及，<a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s Encrypt</a>项目应运而生，它由互联网安全研究小组ISRG（Internet Security Research Group）提供服务，ISRG是来自美国加利福尼亚州的一个公益组织。Let’s Encrypt 得到了 Mozilla、Cisco和 Chrome 等众多公司和机构的支持。</p>
<h1 id="关于Let’s-Encryot"><a href="#关于Let’s-Encryot" class="headerlink" title="关于Let’s Encryot"></a>关于Let’s Encryot</h1><p>Let’s Encrypt 是一个新的 CA，他能够提供一种非常容易的方式来获取和安装免费的 TLS/SSL 证书，从而在 web 服务器上启用 HTTPS 加密。他通过提供软件客户端 letsencrypt 来简化这个过程，它企图自动完成大部分所需的必要步骤。当前，Let’s Encrypt 仍然处在公开测试阶段，他整个获取和安装证书的流程只在 Apache 服务器上实现了全部自动化。然而 Let’s Encrypt 也可以很容易的在其他不同的服务器上获取和安装免费的 SSL 证书。<br><img src="/img/2016-12-16-nginx-letsencrypt.png" alt="验证流程"></p>
<p>申请 Let’s Encrypt 证书不仅免费、代码开源，而且配置简单，不过每次申请只有90天的有效期，但可以通过脚本定期更新，配置好之后一劳永逸。</p>
<p>下面就开始来一起看看吧～</p>
<h1 id="第一步：创建-LET’S-ENCRYPT-账号（如何你没有的话-并生成CSR文件"><a href="#第一步：创建-LET’S-ENCRYPT-账号（如何你没有的话-并生成CSR文件" class="headerlink" title="第一步：创建 LET’S ENCRYPT 账号（如何你没有的话),并生成CSR文件"></a>第一步：创建 LET’S ENCRYPT 账号（如何你没有的话),并生成CSR文件</h1><p>为了区分其他，我们现创建一个文件夹，用来单独存放账号、证书和key</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">mkdir</span> ssl</div><div class="line"><span class="built_in">cd</span> ssl</div></pre></td></tr></table></figure>
<p>Let’s Encrypt使用一个私钥来进行账号的创建与登陆，因此我们需要使用openssl创建一个account.key。首先我们需要看下我们的openssl的安装目录，并记录下openssl.cnf 文件的地址。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl <span class="built_in">version</span> –<span class="keyword">a</span></div></pre></td></tr></table></figure>
<p>从这里我们可以看到当出openssl的安装路径</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">OpenSSL <span class="number">1.0</span><span class="number">.2</span>g  <span class="number">1</span> Mar <span class="number">2016</span></div><div class="line">built <span class="string">on:</span> reproducible build, date unspecified</div><div class="line"><span class="string">platform:</span> debian-amd64</div><div class="line"><span class="string">options:</span>  bn(<span class="number">64</span>,<span class="number">64</span>) rc4(<span class="number">16</span>x,<span class="keyword">int</span>) des(idx,cisc,<span class="number">16</span>,<span class="keyword">int</span>) blowfish(idx) </div><div class="line"><span class="string">compiler:</span> cc -I. -I.. -I..<span class="regexp">/include  -fPIC -DOPENSSL_PIC -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -m64 -DL_ENDIAN -g -O2 -fdebug-prefix-map=/</span>build<span class="regexp">/openssl-wIGtVG/</span>openssl<span class="number">-1.0</span><span class="number">.2</span>g=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=<span class="number">2</span> -Wl,-Bsymbolic-functions -Wl,-z,relro -Wa,--noexecstack -Wall -DMD32_REG_T=<span class="keyword">int</span> -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM -DECP_NISTZ256_ASM</div><div class="line"><span class="string">OPENSSLDIR:</span> <span class="string">"/usr/lib/ssl"</span> <span class="comment">//这个就是我们需要的openssl的路径了</span></div></pre></td></tr></table></figure>
<p>这一步完成后，我们开始我们的第一步</p>
<h2 id="创建Let’s-Encrypt私钥"><a href="#创建Let’s-Encrypt私钥" class="headerlink" title="创建Let’s Encrypt私钥"></a>创建Let’s Encrypt私钥</h2><p>首先进入我们刚刚的ssl 文件夹，然后生成私钥<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ssl</div><div class="line">openssl genrsa <span class="number">4096</span> &gt; account.<span class="type">key</span></div></pre></td></tr></table></figure></p>
<h2 id="创建CSR-Certificate-Signing-Request，证书签名请求-文件"><a href="#创建CSR-Certificate-Signing-Request，证书签名请求-文件" class="headerlink" title="创建CSR(Certificate Signing Request，证书签名请求) 文件"></a>创建CSR(Certificate Signing Request，证书签名请求) 文件</h2><blockquote>
<p>ACME协议 (Let’s Encrypt所使用的) 需要一个csr文件，用来进行证书签名和证书更新。</p>
</blockquote>
<p>将需要加密的域名加到下面的代码中，目前一张证书最多可以加密 100 个域名，注意命令行中的域名换成你自己的域名：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openssl genrsa <span class="number">4096</span> &gt; <span class="built_in">domain</span>.<span class="built_in">key</span></div><div class="line"></div><div class="line">openssl req -<span class="built_in">new</span> -sha256 -<span class="built_in">key</span> <span class="built_in">domain</span>.<span class="built_in">key</span> -subj <span class="string">"/"</span> -reqexts SAN -config &lt;(cat /usr/lib/ssl/openssl.cnf &lt;(<span class="built_in">printf</span> <span class="string">"[SAN]\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com"</span>)) &gt; <span class="built_in">domain</span>.csr</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：openssl.cnf 文件的位置可能会因为linux版本的不同而有变，我们只需要在上一步中的openssl 路径后面加上/openssl.cnf </p>
</blockquote>
<p>现在我们已经生成了csr和私钥，接下来就到了比较纠结的一步了，需要证明你拥有该域名</p>
<h2 id="配置域名验证"><a href="#配置域名验证" class="headerlink" title="配置域名验证"></a>配置域名验证</h2><p>CA 在签发 DV（Domain Validation）证书时，需要验证域名所有权。传统 CA 的验证方式一般是往 admin@youmail.com 发验证邮件，而 Let’s Encrypt 是在你的服务器上生成一个随机验证文件，再通过创建 CSR 时指定的域名访问，如果可以访问则表明你对这个域名有控制权。 首先创建用于存放验证文件的目录，然后通过 “.well-known/acme-challenge/“ 这个URL来访问到验证文件. 注意: Let’s Encrypt 会对你的服务器做一次http请求来进行验证，因此你需要保证80端口能够访问：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">mkdir</span> -p /<span class="built_in">var</span>/www/challenges</div></pre></td></tr></table></figure>
<p>然后配置一个 HTTP 服务，以 Nginx 为例：(注意：这里的端口是80，不是443）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//这个是新增加的一个servr</div><div class="line">server &#123;</div><div class="line"></div><div class="line">listen 80;</div><div class="line">server_name yoursite.com www.yoursite.com;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ( <span class="variable">$request_uri</span> !~ <span class="string">"/.well-known/acme-challenge/*"</span> ) &#123; <span class="comment"># 让 Let's Encrypt 成功访问到验证文件不受 301 影响</span></div><div class="line"><span class="built_in">return</span> 301 https://yoursite.com<span class="variable">$request_uri</span>; <span class="comment"># 注意进行301重定向到https，否则通过http仍能访问你的站点</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">location /.well-known/acme-challenge/ &#123;</div><div class="line"><span class="built_in">alias</span> /var/www/challenges/;</div><div class="line">try_files <span class="variable">$uri</span> =404;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#...你的其他配置</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个验证服务以后更新证书还要用到，需要一直保留。</p>
</blockquote>
<h2 id="获取网站证书"><a href="#获取网站证书" class="headerlink" title="获取网站证书"></a>获取网站证书</h2><p>先回到我们的ssl目录，然后把 acme-tiny 脚本保存到 ssl 目录</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd</div><div class="line">cd ssl</div><div class="line">wget https:<span class="comment">//raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py</span></div><div class="line">sudo chmod +x acme_tiny<span class="selector-class">.py</span>  </div><div class="line">python acme_tiny<span class="selector-class">.py</span> --account-key ./account<span class="selector-class">.key</span> --csr ./domain<span class="selector-class">.csr</span> --acme-dir /var/www/challenges/ &gt; ./signed.crt</div></pre></td></tr></table></figure>
<p>如果一切正常，当前目录下就会生成一个 signed.crt，这就是申请好的证书文件。</p>
<h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><p>证书生成后，就可以把它配置在web 服务器上了，需要注意的是，Nginx需要追加一个Let’s Encrypt的中间证书，在 Nginx 配置中，需要把中间证书和网站证书合在一起：<br>``<br>wget -O - <a href="https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem" target="_blank" rel="external">https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem</a> &gt; intermediate.pem<br>cat signed.crt intermediate.pem &gt; chained.pem</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">最终，修改 Nginx 中有关证书的配置并 reload 服务即可：</div><div class="line"></div><div class="line"><span class="meta">## 修改 Nginx 中有关证书的配置并 reload 服务</span></div></pre></td></tr></table></figure>
<p>server {<br>listen 443;<br>server_name yoursite.com, www.yoursite.com;</p>
<p>ssl on;<br>ssl_certificate /path/to/chained.pem;<br>ssl_certificate_key /path/to/domain.key;<br>ssl_session_timeout 5m;<br>ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA;<br>ssl_session_cache shared:SSL:50m;<br>ssl_prefer_server_ciphers on;</p>
<p>#…你的其他配置<br>}</p>
<p>server {</p>
<p>listen 80;<br>server_name yoursite.com www.yoursite.com;</p>
<p>if ( $request_uri !~ “/.well-known/acme-challenge/*” ) { # 让 Let’s Encrypt 成功访问到验证文件不受 301 影响<br>return 301 <a href="https://yoursite.com$request_uri" target="_blank" rel="external">https://yoursite.com$request_uri</a>; # 注意进行<br>301重定向到https，否则通过http仍能访问你的站点<br>}</p>
<p>location /.well-known/acme-challenge/ {<br>alias /var/www/challenges/;<br>try_files $uri =404;<br>}</p>
<p>#…你的其他配置<br>}</p>
<h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p>好了，现在就能重启你的nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nginx <span class="_">-s</span> reload</div></pre></td></tr></table></figure></p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>恭喜！你的网站已经使用上了HTTPS。 但Let’s Encrypt 证书有效期只有90天, 所以需要定期更新。现在只需要写一个更新脚本并把它放到定时任务中即可。</p>
<p>在ssl的文件夹内进行如下操作<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">cd</span></div><div class="line"><span class="keyword">cd</span> ssl</div><div class="line">touch renew_cert.<span class="keyword">sh</span></div><div class="line"><span class="keyword">vi</span> renew_cert.<span class="keyword">sh</span></div></pre></td></tr></table></figure></p>
<p>然后在renew_cert.sh中输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/sh</span></div><div class="line">python /root/ssl/acme_tiny.py --account-key /root/ssl/account.key --csr /root/ssl/domain.csr --acme-dir /var/www/challenges/ &gt; /tmp/signed.crt || <span class="built_in">exit</span></div><div class="line">wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</div><div class="line">cat /tmp/signed.crt intermediate.pem &gt; /root/ssl/chained.pem</div><div class="line">service nginx reload</div></pre></td></tr></table></figure></p>
<p>定时任务可以设置为每个月执行一次：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> * * /root/ssl/acme-tiny/renew_cert.sh <span class="number">2</span>&gt;&gt; /var/<span class="keyword">log</span>/acme_tine.<span class="keyword">log</span></div></pre></td></tr></table></figure></p>
<p>以上就是整个的全过程了。欢迎享受HTTPS之旅～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司任务不是很重，适配iOS 10 ATS 已经成为了项目这一个月的任务，杨老大负责任的把这个重担一个人扛下了，因此我等小民就只能自己去研究了，于是就寻思着给自己的博客加上ssl验证，有个小绿锁🔒 看起来确实是舒坦很多。在这里就记录下全过程。&lt;br&gt;
    
    </summary>
    
    
      <category term="https" scheme="http://www.zhimakaiyuan.com/tags/https/"/>
    
      <category term="瞎折腾" scheme="http://www.zhimakaiyuan.com/tags/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>Xcode8在Objective-C中集成Charts 3.0（全是坑！！！）</title>
    <link href="http://www.zhimakaiyuan.com/2016/12/06/Xcode8-Uses-Charts-Objective-C/"/>
    <id>http://www.zhimakaiyuan.com/2016/12/06/Xcode8-Uses-Charts-Objective-C/</id>
    <published>2016-12-06T09:04:26.000Z</published>
    <updated>2016-12-16T08:08:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>用cocoapods集成Charts说多了都是泪，全是坑！不过全都搞好以后，画图表还是很方便的。<br><a id="more"></a><br> 不知咋滴，一大早起来后把项目clean了一下，然后把pod文件全删了，重新运行<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod <span class="keyword">install</span></div></pre></td></tr></table></figure></p>
<p>然后再clean，居然好了。。。<br>下面记录下踩坑的整个过程</p>
<h1 id="Charts-是何方神圣"><a href="#Charts-是何方神圣" class="headerlink" title="Charts 是何方神圣"></a>Charts 是何方神圣</h1><p>Charts是一套非常漂亮的开源图表组件，它是<a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="external">MPAndroidChart</a>在苹果端的移植版本，同时支持iOS/tvOS/OSX平台，开源地址<a href="https://github.com/danielgindi/Charts" target="_blank" rel="external">Github</a>。</p>
<p>同时，Charts是用 Swift 语言编写的，能够在 Swift 和 Objc 工程中使用。</p>
<h1 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h1><ul>
<li>Xcode 8.0 / Swift 3.0 (如果要支持 Swift 2.3 ，请查看 <a href="https://github.com/danielgindi/Charts/tree/v2.3.0" target="_blank" rel="external">Charts 2.3</a>)</li>
<li>iOS &gt;= 8.0</li>
<li>tvOS &gt;= 9.0</li>
<li>macOS &gt;= 10.11</li>
</ul>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>本文使用的是通过cocopods 来安装的，中间的过程有点曲折</p>
<h2 id="通过-cocoapods-集成"><a href="#通过-cocoapods-集成" class="headerlink" title="通过 cocoapods 集成"></a>通过 cocoapods 集成</h2><p>如果项目还未使用cocoapods，可用终端在根目录下输入<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod <span class="keyword">init</span></div></pre></td></tr></table></figure></p>
<p>然后在项目的 Podfile 文件中添加 Charts<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">pod</span> <span class="string">'Charts'</span>, <span class="string">'~&gt; 3.0'</span></div></pre></td></tr></table></figure></p>
<p>如果不出意外的话，会在安装过程中报个小错</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[!] Pods written <span class="keyword">in</span> Swift can only be integrated <span class="keyword">as</span> frameworks; <span class="keyword">add</span> `use_frameworks!` <span class="keyword">to</span> your Podfile <span class="keyword">or</span> target <span class="keyword">to</span> opt <span class="keyword">into</span> <span class="keyword">using</span> it. The Swift Pod being used <span class="keyword">is</span>: Charts</div></pre></td></tr></table></figure>
<p>恭喜踩到了第一个坑</p>
<h3 id="为什么呢"><a href="#为什么呢" class="headerlink" title="为什么呢"></a>为什么呢</h3><p>原来根据苹果的相关政策，在 Swift项目中苹果将不允许你私自包含静态库了，因此我们的解决办法是,在 podfile 文件中 添加这么一句<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pod <span class="string">'Charts'</span>, <span class="string">'~&gt; 3.0'</span></div><div class="line">use_frameworks!</div></pre></td></tr></table></figure></p>
<p>use_frameworks！选项是告诉 CocoaPods 使用 framework 而不是静态库。这在 Swift 项目中是必选。</p>
<p>完成之后，我们开始导入</p>
<h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><p>在项目的根目录下，输入<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod <span class="keyword">install</span></div></pre></td></tr></table></figure></p>
<p>静待几分钟后，会有提示倒入成功<br>这时候，我们需要打开 xcworkspace 文件,<strong>注意哦，是 xcworkspace 不再是原来的 xcodeproj文件了 </strong></p>
<p>因为我们的项目是 OC 的，而 Charts 是用 Swift 编写的，所以需要创建一个桥接文件<br><img src="/img/swift_link.png" alt="桥接"><br>完成后，会有提示是否需要桥接，点击 Create Bridging Header</p>
<p><img src="/img/2016_12_16creat_header.png" alt="提示"></p>
<blockquote>
<p>执行完这一步后，如果有报错之类的，可以先把项目 clean 一下 <em>敲黑板</em>  <em>这是一道送分题，千万不能忘</em></p>
</blockquote>
<p>接着在桥接文件 项目名-Bridging-Header.h 中，写上要引用的 Swift 头文件。<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">import</span> <span class="built_in">Charts</span>;</div></pre></td></tr></table></figure></p>
<h1 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h1><h1 id="进入测试阶段"><a href="#进入测试阶段" class="headerlink" title="进入测试阶段"></a>进入测试阶段</h1><p>在ViewController.m中加入如下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.184</span> green:<span class="number">1.000</span> blue:<span class="number">0.738</span> alpha:<span class="number">1.000</span>];</div><div class="line">lineView = [[LineChartView alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="keyword">self</span>.view.bounds.size.height / <span class="number">3.0</span>f,[<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.height / <span class="number">3.0</span>)];</div><div class="line">lineView.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.184</span> green:<span class="number">1.000</span> blue:<span class="number">0.738</span> alpha:<span class="number">1.000</span>];</div><div class="line">[<span class="keyword">self</span>.view addSubview:lineView];</div><div class="line"></div><div class="line">lineView.dragEnabled = <span class="literal">YES</span>;<span class="comment">//是否拖拽，</span></div><div class="line">lineView.drawGridBackgroundEnabled = <span class="literal">NO</span>;<span class="comment">//绘制网格背景</span></div><div class="line">lineView.scaleXEnabled = <span class="literal">NO</span>;</div><div class="line">lineView.pinchZoomEnabled = <span class="literal">NO</span>;</div><div class="line">lineView.descriptionText = <span class="string">@"每月收入支出图"</span>;</div><div class="line"><span class="comment">//X轴设置</span></div><div class="line">ChartXAxis *xAxis = lineView.xAxis;</div><div class="line">xAxis.labelPosition = XAxisLabelPositionBothSided;<span class="comment">//X轴样式</span></div><div class="line">xAxis.drawLabelsEnabled = <span class="literal">YES</span>;<span class="comment">//X轴是否需要绘制文字</span></div><div class="line">xAxis.drawAxisLineEnabled = <span class="literal">YES</span>;<span class="comment">//X轴绘制</span></div><div class="line">xAxis.drawGridLinesEnabled = <span class="literal">NO</span>;<span class="comment">//X轴网格绘制</span></div><div class="line">xAxis.axisLineWidth = <span class="number">0.4</span>f;<span class="comment">//数轴宽度</span></div><div class="line">[xAxis setLabelCount:<span class="number">10</span> force:<span class="literal">NO</span>];<span class="comment">//X轴数量一般默认是6个</span></div><div class="line"></div><div class="line"><span class="comment">//Y轴设置</span></div><div class="line">ChartYAxis *yAxis = lineView.leftAxis;</div><div class="line">yAxis.spaceTop = <span class="number">.5</span>f;<span class="comment">//Y轴顶部的最大值的百分比</span></div><div class="line">yAxis.labelFont = [<span class="built_in">UIFont</span> fontWithName:<span class="string">@"HelveticaNeue-Light"</span> size:<span class="number">12.</span>f];</div><div class="line">[yAxis setLabelCount:<span class="number">5</span> force:<span class="literal">NO</span>];<span class="comment">//Y轴坐标个数</span></div><div class="line">yAxis.labelTextColor = [<span class="built_in">UIColor</span> blackColor];<span class="comment">//Y轴坐标文字颜色</span></div><div class="line">yAxis.labelPosition = YAxisLabelPositionInsideChart;</div><div class="line">yAxis.drawGridLinesEnabled = <span class="literal">NO</span>;<span class="comment">//Y轴网格</span></div><div class="line">yAxis.axisLineColor = <span class="built_in">UIColor</span>.blackColor;</div><div class="line"></div><div class="line">lineView.rightAxis.enabled = <span class="literal">NO</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> count = <span class="number">30</span>;</div><div class="line"><span class="keyword">double</span> range = <span class="number">10</span>;</div><div class="line">[<span class="keyword">self</span> setDataCount:count range:range];</div><div class="line"></div><div class="line">[lineView animateWithXAxisDuration:<span class="number">3</span> yAxisDuration:<span class="number">3</span>];</div><div class="line"><span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后随机配置一下数据，就能看到两条曲线了<br>完美🤗<br><img src="/img/SimulatorScreenShot20161216.png" alt="成功截图"><br>demo地址：<a href="https://github.com/muwan/ChartsDemo" target="_blank" rel="external">ChartsDemo</a></p>
<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="http://www.jianshu.com/p/6bf9e2d8e9db" target="_blank" rel="external">Cocoapods 安装参考</a><br><a href="http://www.jianshu.com/p/3af5fd275f05" target="_blank" rel="external">Swift静态库参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用cocoapods集成Charts说多了都是泪，全是坑！不过全都搞好以后，画图表还是很方便的。&lt;br&gt;
    
    </summary>
    
      <category term="吐槽" scheme="http://www.zhimakaiyuan.com/categories/%E5%90%90%E6%A7%BD/"/>
    
      <category term="技术" scheme="http://www.zhimakaiyuan.com/categories/%E5%90%90%E6%A7%BD/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://www.zhimakaiyuan.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Add SSH Key to Your Remote Client</title>
    <link href="http://www.zhimakaiyuan.com/2016/11/03/add-SSH-Key-to-Your-remote-clint/"/>
    <id>http://www.zhimakaiyuan.com/2016/11/03/add-SSH-Key-to-Your-remote-clint/</id>
    <published>2016-11-03T05:26:30.000Z</published>
    <updated>2016-12-14T02:41:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间，买了<a href="http://www.vultr.com/?ref=7026654-3B" target="_blank" rel="external">Vultr</a>家的VPS用作shadowsocks，最近突然很感兴趣，于是捣鼓了下，每次登录的时候都需要输入密码有点麻烦，就找到了如何用ssh登录的方法。<br><a id="more"></a></p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>Mac、VPS（安装的是ubuntu 16.0）</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>ssh除了使用密码验证外，还提供了一种公私密钥的验证方式。客户端生成一个私钥，并生成一个与之对应的公钥，然后将公钥上传到服务器上。</p>
<h1 id="开始准备"><a href="#开始准备" class="headerlink" title="开始准备"></a>开始准备</h1><ol>
<li>在本地机器创建公钥<br>在客户端生成私钥、公钥（注意，在Mac 上完成）<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -<span class="keyword">C</span>  <span class="string">'your email'</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>然后一路回车，生成你自己的密钥对，成功截图如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/309640-f478035471497323.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="密钥对截图"></p>
<ol>
<li>将公钥复制到ssh服务器<br>将前一步骤生成的公钥~/id_rsa.pub文件，复制到ssh服务器对应用户下的~/.ssh/authorized_keys文件,可以有多种方式，这里只介绍常用的一种。<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install ssh-<span class="keyword">copy</span>-<span class="built_in">id</span></div><div class="line">ssh-<span class="keyword">copy</span>-<span class="built_in">id</span> username@hostname  <span class="comment">#将username和hostname替换为你的ssh服务器用户名和IP</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>当ssh服务器username用户目录下尚未有.ssh目录时使用此方式<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat ~<span class="regexp">/.ssh/id</span>_rsa.pub | ssh username<span class="variable">@hostname</span> <span class="string">"mkdir ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys"</span></div></pre></td></tr></table></figure></p>
<p>通用方式<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">scp ~<span class="regexp">/.ssh/id</span>_rsa.pub username@hostname<span class="symbol">:~/</span> <span class="comment">#将公钥文件复制至ssh服务器</span></div><div class="line">ssh username@hostname <span class="comment">#使用用户名和密码方式登录至ssh服务器</span></div><div class="line">mkdir .ssh  <span class="comment">#若.ssh目录已存在，可省略此步</span></div><div class="line">cat id_rsa.pub <span class="meta">&gt;&gt; </span>.ssh/authorized_keys  <span class="comment">#将公钥文件id_rsa.pub文件内容追加到authorized_keys文件</span></div></pre></td></tr></table></figure></p>
<ol>
<li>快捷登录<br>完成以上步骤后，即可使用以下命令直接登录ssh服务器，妈妈再也不用担心你记不住密码了<br>以后登录ssh，只需要在你的Mac上输入 <figure class="highlight plain"><figcaption><span>username@hostname``` 即可不用输入密码啦～</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># 思考</div><div class="line">即使这样，我们还是需要输入远程服务器的ip地址，有时候真的脑容量不够啊，怎么办，怎么办，怎么办！！！</div><div class="line"></div><div class="line">没关系，我们还能实现本地一条命令就能登录</div><div class="line"></div><div class="line">**ssh本身也提供了一种快捷的方式来解决这个问题，往~/.ssh/config配置文件添加你的ssh服务器信息即可**</div><div class="line"></div><div class="line">在本地可客户端（你的Mac）输入</div></pre></td></tr></table></figure></li>
</ol>
<p>vim ~/.ssh/config<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">然后在终端输入 <span class="selector-tag">i</span> 开始插入如下内容：</div></pre></td></tr></table></figure></p>
<p>Host                  name#自定义别名<br>HostName              hostname  #替换为你的ssh服务器ip或domain<br>Port                  22 #ssh服务器端口，默认为22<br>User                  root #ssh服务器用户名<br>IdentityFile          ~/.ssh/id_rsa #第一个步骤生成的公钥文件对应的私钥文件<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">按下ESC，然后依次输入 <span class="symbol">:wq</span></div><div class="line">保存并退出</div><div class="line"></div><div class="line">最终，我们只需要在终端输入</div></pre></td></tr></table></figure></p>
<p>ssh name<br>```<br>就能远程登录我们的VPS啦～</p>
<p>写在最后<br>这篇文章多亏了我们的黄小贱同学 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间，买了&lt;a href=&quot;http://www.vultr.com/?ref=7026654-3B&quot;&gt;Vultr&lt;/a&gt;家的VPS用作shadowsocks，最近突然很感兴趣，于是捣鼓了下，每次登录的时候都需要输入密码有点麻烦，就找到了如何用ssh登录的方法。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.zhimakaiyuan.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="http://www.zhimakaiyuan.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="VPS" scheme="http://www.zhimakaiyuan.com/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>Mac上搭建shadowsocks服务</title>
    <link href="http://www.zhimakaiyuan.com/2016/10/27/Mac%E4%B8%8A%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1/"/>
    <id>http://www.zhimakaiyuan.com/2016/10/27/Mac上搭建shadowsocks服务/</id>
    <published>2016-10-27T06:27:24.000Z</published>
    <updated>2016-12-14T02:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前看着教程自己也乱七八糟的搭建了一个ss的服务端，但是感觉一团糟，于是趁着自己有时间，就重新搭建一下，顺便好好记录下搭建的过程，方便自己，也希望能给其他刚接触的一点帮助。<br>首先我自己的是一台Mac，所以主要记录的也是Mac上的操作，我的vps买的是搬瓦工19.99$的，目前使用感觉还行。<br><a id="more"></a></p>
<h1 id="写在最前面：为什么翻墙？"><a href="#写在最前面：为什么翻墙？" class="headerlink" title="写在最前面：为什么翻墙？"></a>写在最前面：为什么翻墙？</h1><p>应该每个人都有自己的原因，总的来说，还是”赵家人“管得太宽，各种访问不了<br>目前使用的工具也是种类繁多，很多免费的不稳定，速度慢，使用起来也不见得安全，付费的虽然好点，但是依然是使用的别人的代理服务器。<br>因此，还是我们自己来搭一个吧，至于为什么选择ss，主要是觉得搭建比较方便，而且安全性想对较好</p>
<h1 id="需要准备哪些"><a href="#需要准备哪些" class="headerlink" title="需要准备哪些"></a>需要准备哪些</h1><p>电脑（Mac）、vps（ubuntu 16 ＊ 64）</p>
<h1 id="shadowsocks-服务器安装"><a href="#shadowsocks-服务器安装" class="headerlink" title="shadowsocks 服务器安装"></a>shadowsocks 服务器安装</h1><h2 id="登陆你的远程服务器"><a href="#登陆你的远程服务器" class="headerlink" title="登陆你的远程服务器"></a>登陆你的远程服务器</h2><p>打开Mac自带的终端<br>ssh root@你的ip -p 你的ssh端口，若没有特殊分配，一般都是22</p>
<h2 id="更新源软件"><a href="#更新源软件" class="headerlink" title="更新源软件"></a>更新源软件</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root<span class="variable">@localhost:</span>~# sudo apt-get update</div></pre></td></tr></table></figure>
<p>更新完成后，会有提示<br><img src="/img/update-2016-10-27.png" alt="更新源"></p>
<h2 id="安装PIP环境"><a href="#安装PIP环境" class="headerlink" title="安装PIP环境"></a>安装PIP环境</h2><p><del>root@localhost:~# sudo apt-get install python-pip</del><br>由于原作者已经不再更新 pip 下的源代码，故不再使用 pip 安装 Shadowsocks。</p>
<h2 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h2><p> <del>pip install shadowsocks</del></p>
<p>由于原作者已经不再更新 pip 下的源代码，故不再使用 pip 安装 Shadowsocks，而是改为下载 Github 的 master 分支来安装。如果在一段时间后，版本升级了，则先卸载，并再次执行本脚本就可以升级为最新版。这里采用了<a href="https://teddysun.com/342.html" target="_blank" rel="external">秋水逸冰的博客</a>，采用该一键安装 Python 版 Shadowsocks 的最新版，同时安装了 Python 包管理工具 pip。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget --<span class="keyword">no</span>-check-certificate http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/teddysun/shadowsocks_install/master/shadowsocks.<span class="keyword">sh</span></div><div class="line">chmod +<span class="keyword">x</span> shadowsocks.<span class="keyword">sh</span></div><div class="line">./shadowsocks.<span class="keyword">sh</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee shadowsocks.<span class="built_in">log</span></div></pre></td></tr></table></figure>
<p>安装完成后，脚本提示如下<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Congratulations, shadowsocks install completed!</div><div class="line">Your Server IP:your_server_ip</div><div class="line">Your Server Port:your_server_port</div><div class="line">Your Password:your_password</div><div class="line">Your Local IP:<span class="number">127.0</span>.<span class="number">0.1</span></div><div class="line">Your Local Port:<span class="number">1080</span></div><div class="line">Your Encryption <span class="function"><span class="keyword">Method</span>:</span>aes-<span class="number">256</span>-cfb</div><div class="line"></div><div class="line">Welcome <span class="keyword">to</span> visit:https:<span class="comment">//teddysun.com/342.html</span></div><div class="line">Enjoy it!</div></pre></td></tr></table></figure></p>
<h2 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./shadowsocks<span class="selector-class">.sh</span> uninstall</div></pre></td></tr></table></figure>
<h2 id="进入配置"><a href="#进入配置" class="headerlink" title="进入配置"></a>进入配置</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi <span class="regexp">/etc/</span>shadowsocks.json</div></pre></td></tr></table></figure>
<p>键盘上按下「i」键，进入Insert mode</p>
<h3 id="单用户配置文件"><a href="#单用户配置文件" class="headerlink" title="单用户配置文件"></a>单用户配置文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</div><div class="line"><span class="attr">"server_port"</span>:<span class="number">8989</span>,</div><div class="line"><span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</div><div class="line"><span class="attr">"local_port"</span>:<span class="number">1080</span>,</div><div class="line"><span class="attr">"password"</span>:<span class="string">"yourpassword"</span>,</div><div class="line"><span class="attr">"timeout"</span>:<span class="number">300</span>,</div><div class="line"><span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</div><div class="line"><span class="attr">"fast_open"</span>: <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多用户配置文件"><a href="#多用户配置文件" class="headerlink" title="多用户配置文件"></a>多用户配置文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</div><div class="line"><span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</div><div class="line"><span class="attr">"local_port"</span>:<span class="number">1080</span>,</div><div class="line"><span class="attr">"port_password"</span>:&#123;</div><div class="line"><span class="attr">"8989"</span>:<span class="string">"password0"</span>,</div><div class="line"><span class="attr">"9001"</span>:<span class="string">"password1"</span>,</div><div class="line"><span class="attr">"9002"</span>:<span class="string">"password2"</span>,</div><div class="line"><span class="attr">"9003"</span>:<span class="string">"password3"</span>,</div><div class="line"><span class="attr">"9004"</span>:<span class="string">"password4"</span></div><div class="line">&#125;,</div><div class="line"><span class="attr">"timeout"</span>:<span class="number">300</span>,</div><div class="line"><span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</div><div class="line"><span class="attr">"fast_open"</span>: <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要注意,””{}不要漏了<br>配置完成之后，先按「esc」退出，然后按一下「：」冒号键进入「Last line mode」，例如： </p>
<p>: w filename （输入 「w filename」将文章以指定的文件名filename保存） </p>
<p>: wq (输入「wq」，存盘并退出vi) </p>
<p>: q! (输入q!， 不存盘强制退出vi)<br>这里我们直接存盘并退出，「：wq」</p>
<h2 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">启动：/etc/<span class="keyword">init</span>.d/shadowsocks start</div><div class="line">停止：/etc/<span class="keyword">init</span>.d/shadowsocks stop</div><div class="line">重启：/etc/<span class="keyword">init</span>.d/shadowsocks restart</div><div class="line">状态：/etc/<span class="keyword">init</span>.d/shadowsocks status</div></pre></td></tr></table></figure>
<p>参考链接<br><a href="http://jiji262.github.io/2016/09/28/setup-Shadowsocks-on-ubuntu-1604/" target="_blank" rel="external">http://jiji262.github.io/2016/09/28/setup-Shadowsocks-on-ubuntu-1604/</a><br><a href="https://teddysun.com/342.html" target="_blank" rel="external">https://teddysun.com/342.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前看着教程自己也乱七八糟的搭建了一个ss的服务端，但是感觉一团糟，于是趁着自己有时间，就重新搭建一下，顺便好好记录下搭建的过程，方便自己，也希望能给其他刚接触的一点帮助。&lt;br&gt;首先我自己的是一台Mac，所以主要记录的也是Mac上的操作，我的vps买的是搬瓦工19.99$的，目前使用感觉还行。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.zhimakaiyuan.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="http://www.zhimakaiyuan.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="翻墙" scheme="http://www.zhimakaiyuan.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="Shadowsocks" scheme="http://www.zhimakaiyuan.com/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Objective-C 2.0笔记</title>
    <link href="http://www.zhimakaiyuan.com/2016/10/10/Effective-Objective-C-2-0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.zhimakaiyuan.com/2016/10/10/Effective-Objective-C-2-0笔记/</id>
    <published>2016-10-10T02:51:38.000Z</published>
    <updated>2016-12-14T02:41:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一个博客写了Effective Objective-C 2.0 的总的概览，这一章准备记录一下本书中提到的编写高质量iOS 与 OS X 代码的52个有效方法</p>
<a id="more"></a>
<p><em>第1条:了解 Objective-C 语言的起源</em><br><em>第2条:在类的头文件中尽量少引入其他文件</em><br><em>第3条:多用字面量语法，少用与之等价的方法</em><br><em>第4条:多用类型常量，少用 #define 预处理指令</em><br><em>第5条:用枚举表示状态、选项、状态码</em></p>
<p><em>第6条:理解“属性”这一概念</em><br><em>第7条:在对象内部尽量直接访问实例变量</em><br><em>第8条:理解“对象等同性”这一概念</em><br><em>第9条:以“类族模式”隐藏实现细节</em><br><em>第10条:在既有类中使用关联对象存放自定义数据</em><br><em>第11条:理解 obje_msgSend 的作用</em><br><em>第12条:理解消息转发机制</em><br><em>第13条:用“方法调配技术”测试“黑盒方法”</em><br><em>第14条:理解“类对象”的用意</em></p>
<p><em>第15条:用前缀避免命名空间冲突</em><br><em>第16条:提供“全能初始化方法”</em><br><em>第17条:实现 description 方法</em><br><em>第18条:尽量使用不可变对象</em><br><em>第19条:使用清晰而协调的命名方式</em><br><em>第20条:为私有方法名加前缀</em><br><em>第21条:理解 Objective-C 错误模型</em><br><em>第22条:理解 NSCopying</em></p>
<p><em>第23条:通过委托与数据源协议进行对象间通信</em><br><em>第24条:将类的实现代码分散到便于管理的数个分类之中</em><br><em>第25条:总是为第三方类的分类名称加前缀</em><br><em>第26条:勿在分类中声明属性</em><br><em>第27条:使用 “class-continuation 分类”隐藏实现细节</em><br><em>第28条:通过协议提供匿名对象</em></p>
<p><em>第29条:理解引用计数</em><br><em>第30条:以 ARC 简化引用计数</em><br><em>第31条:</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一个博客写了Effective Objective-C 2.0 的总的概览，这一章准备记录一下本书中提到的编写高质量iOS 与 OS X 代码的52个有效方法&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://www.zhimakaiyuan.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://www.zhimakaiyuan.com/tags/iOS/"/>
    
      <category term="笔记" scheme="http://www.zhimakaiyuan.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Effective-Objective-C 2.0笔记（概览）</title>
    <link href="http://www.zhimakaiyuan.com/2016/02/01/Effective-Objective-C-2-0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A6%82%E8%A7%88%EF%BC%89/"/>
    <id>http://www.zhimakaiyuan.com/2016/02/01/Effective-Objective-C-2-0笔记（概览）/</id>
    <published>2016-02-01T07:19:23.000Z</published>
    <updated>2016-12-14T02:41:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直想说要读完这本书，结果在咸鱼老湿的督促下，还是没能看完，努力还是要靠自己啊，今天正好有时间，就先把标题里在这里。<br>我们先定个小目标，比方说，先把这52个有效方法写出来，以后再慢慢填充。<br>编写高质量iOS与OS X代码的52个有效方法。<br><a id="more"></a><br>本书分为七章，分别是</p>
<ol>
<li><p>熟悉 Objective-C<br>通论该语言的核心概念</p>
</li>
<li><p>对象、消息、运行期<br>对象之间能够关联与交互，这是面向对象语言的重要特征。贲张讲述这些特性，并深入研究代码在运行期的行为。</p>
</li>
<li><p>接口与 API 设计<br>很少有那种写完就不再复用的代码。即使代码不向更多人公开，也依然有可能用在自己的多个项目中。本章讲解如何编写与 Objective-C 搭配得宜的类。</p>
</li>
<li><p>协议与分类<br>协议与分类是两个需要掌握的重要语言特性。若运用得当，则可以令代码易读、易维护且少出错。本章将帮助读者精通这两个概念。</p>
</li>
<li><p>内存管理<br>Objective-C 语言以引用计数来管理内存，这令许多初学者纠结，要是用过以“垃圾收集器” (garbage collector)来管理内存的语言，那么更会如此。“自动引用计数”机制缓解了此问题，不过使用时有很多重要的注意事项，以确保对象模型正确，不致内存泄漏。本章提醒读者注意内存管理中易犯的错误。</p>
</li>
<li><p>块与大中枢派发<br>苹果公司引入了“块”这一概念，其余法类似于 C 语言扩展中的“闭包”(closure)。在 Objective-C 语言中，我们通常采用块来实现一些原来需要很多样板代码才能完成的事情，块还能实现“代码分离”(code separation)。“大中枢派发”(Grand Central Dispatch,GCD) 提供了一套用于多线程环境的简单接口。“块”可视为GCD的任务，根据系统资源状况，这些任务也许能并发执行。本章将教会读者如何充分运用这两项核心技术。</p>
</li>
<li><p>系统框架<br>大家通常会用 Objective-C 开开发Mac OS X 或 iOS 程序。在这两种情况下都有一套完整的系统框架可供使用，前者名为 Cocoa ，后者名为 Cocoa Touch。本章将总览这些框架，并深入研究其中某些类。</p>
</li>
</ol>
<p>共有52个有效方法，会在下一章博客中写出来</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直想说要读完这本书，结果在咸鱼老湿的督促下，还是没能看完，努力还是要靠自己啊，今天正好有时间，就先把标题里在这里。&lt;br&gt;我们先定个小目标，比方说，先把这52个有效方法写出来，以后再慢慢填充。&lt;br&gt;编写高质量iOS与OS X代码的52个有效方法。&lt;br&gt;
    
    </summary>
    
      <category term="学习" scheme="http://www.zhimakaiyuan.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://www.zhimakaiyuan.com/tags/iOS/"/>
    
      <category term="笔记" scheme="http://www.zhimakaiyuan.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>开始健身</title>
    <link href="http://www.zhimakaiyuan.com/2016/01/15/%E5%BC%80%E5%A7%8B%E5%81%A5%E8%BA%AB/"/>
    <id>http://www.zhimakaiyuan.com/2016/01/15/开始健身/</id>
    <published>2016-01-15T04:03:40.000Z</published>
    <updated>2016-12-14T02:47:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/ideal.JPG" alt="目标身材"></p>
<p>####终于开始健身了，今天将是第三次去了，还是矫正体型，看来健身的道路很漫长啊。距离目标身材还很遥远，加油吧，骚年！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/ideal.JPG&quot; alt=&quot;目标身材&quot;&gt;&lt;/p&gt;
&lt;p&gt;####终于开始健身了，今天将是第三次去了，还是矫正体型，看来健身的道路很漫长啊。距离目标身材还很遥远，加油吧，骚年！&lt;/p&gt;

    
    </summary>
    
      <category term="生活" scheme="http://www.zhimakaiyuan.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="碎碎念" scheme="http://www.zhimakaiyuan.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
      <category term="健身" scheme="http://www.zhimakaiyuan.com/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods的使用与安装</title>
    <link href="http://www.zhimakaiyuan.com/2016/01/12/CocoaPods%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>http://www.zhimakaiyuan.com/2016/01/12/CocoaPods的使用与安装/</id>
    <published>2016-01-12T05:07:11.000Z</published>
    <updated>2016-12-14T02:41:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是CocoaPods"><a href="#什么是CocoaPods" class="headerlink" title="什么是CocoaPods"></a>什么是CocoaPods</h2><p>CocoaPods是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具，而其本身是利用ruby的依赖管理gem进行构建的。因此，在解析整合过程中，最重要的几个gems分别是：CocoaPods/CocoaPods, CocoaPods/Core, 和 CocoaPods/Xcodeproj。<br>在我们的工程里面会用到JSONKit、AFNetWorking等第三方开源库，首次在工程中引入这些第三方库的时候，会涉及许多配置，尤其是在build phases和linker flags配置中过程中，会引起许多人为因素的错误。CocoaPods的出现简化了这一切，并且可以通过CocoaPods查找新的第三方库。<br><a id="more"></a></p>
<h2 id="CocoaPods的工作原理"><a href="#CocoaPods的工作原理" class="headerlink" title="CocoaPods的工作原理"></a>CocoaPods的工作原理</h2><p>CocoaPods的原理是将所有的依赖库都放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个 .a文件即可。</p>
<h2 id="CocoaPods的安装"><a href="#CocoaPods的安装" class="headerlink" title="CocoaPods的安装"></a>CocoaPods的安装</h2><p>上面已经提到了，CocoaPods是利用Ruby的依赖管理gem进行构建，因此安装CocoaPods需要在ruby的环境下。</p>
<h3 id="1-Ruby环境搭建"><a href="#1-Ruby环境搭建" class="headerlink" title="1.Ruby环境搭建"></a>1.Ruby环境搭建</h3><p>Mac OS是自带ruby环境的，但是保险起见，还是需要更新一下。<br>a.查看当前ruby版本<br>打开Mac的terminal 输入ruby -v代码如下<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ruby -v</div><div class="line">ruby <span class="number">2.0</span>.0p645 (<span class="number">2015</span>-<span class="number">04</span>-<span class="number">13</span> revision <span class="number">50299</span>) [universal.x86_64-darwin15](<span class="comment">#)</span></div></pre></td></tr></table></figure></p>
<p>b.更换ruby源<br>终端输入如下命令（ruby的软件源rubygems.org因为使用的亚马逊的云服务，所以被墙了，需要更新一下ruby的源，国内常用的镜像服务有淘宝阿里云的<a href="https://ruby.taobao.org/" target="_blank" rel="external"></a>，山东理工大学的<a href="http://ruby.sdutlinux.org/" target="_blank" rel="external"></a>,一般使用淘宝的）<br>gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="external">https://rubygems.org/</a><br>gem sources -a <a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a><br>gem sources -l  （用来检查使用替换镜像位置成功）<br>代码如下<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ gem sources --remove <span class="string">https:</span><span class="comment">//rubygems.org/</span></div><div class="line"><span class="string">https:</span><span class="comment">//rubygems.org/ removed from sources</span></div><div class="line">$ gem sources -a <span class="string">https:</span><span class="comment">//ruby.taobao.org/</span></div><div class="line"><span class="string">https:</span><span class="comment">//ruby.taobao.org/ added to sources</span></div><div class="line">$ gem sources -l</div><div class="line">*** CURRENT SOURCES ***</div><div class="line"><span class="symbol"></span></div><div class="line">http:<span class="comment">//rubygems-china.oss.aliyuncs.com</span></div><div class="line"><span class="string">https:</span><span class="comment">//ruby.taobao.org/</span></div></pre></td></tr></table></figure></p>
<h3 id="2-升级gem"><a href="#2-升级gem" class="headerlink" title="2.升级gem"></a>2.升级gem</h3><p>sudo gem update –system<br>升级成功后，代码如下<br><img src="/img/2016-01-12.PNG" alt=""></p>
<h3 id="3-下载安装CocoaPods"><a href="#3-下载安装CocoaPods" class="headerlink" title="3.下载安装CocoaPods"></a>3.下载安装CocoaPods</h3><p>安装CocoaPods（OS X 10.11以前）</p>
<ul>
<li>sudo gem install cocoapods<br>安装CocoaPods（10.11后苹果升级了安全策略）</li>
<li>sudo gem install -n /usr/local/bin cocoapods<br>安装更新后，会有 gem installed提示</li>
</ul>
<p>所有的项目的Podspec文件都托管在<a href="https://github.com/CocoaPods/Specs。第一次执行pod" target="_blank" rel="external">https://github.com/CocoaPods/Specs。第一次执行pod</a> setup时，CocoaPods会将这些podspec索引文件更新到本地的 /.cocoapods/目录下，这个索引文件比较大，有80M左右。所以第一次更新时非常慢，一般更新了将近1个小时才完成。<br>一个叫akinliu的朋友在gitcafe和oschina上建立了CocoaPods索引库的镜像，因为gitcafe和oschina都是国内的服务器，所以在执行索引更新操作时，会快很多。如下操作可以将CocoaPods设置成使用gitcafe镜像：<br>1.移除原有服务器</p>
<ul>
<li>pod repo remove master<br>2.添加境内服务器（建议使用第一个）</li>
<li>pod repo add master <a href="https://gitcafe.com/akuandev/Specs.git" target="_blank" rel="external">https://gitcafe.com/akuandev/Specs.git</a></li>
<li>pod repo add master <a href="http://git.oschina.net/akuandev/Specs.git(开源中国较慢" target="_blank" rel="external">http://git.oschina.net/akuandev/Specs.git(开源中国较慢</a>)<br>使用及截图如下<br><img src="/img/89744051-0CCB-4D1E-9CC0-7AE6BCEFB0B1.png" alt="" title="移除原有服务器"><br><img src="/img/4AF9C273-72BA-45C0-9F35-9E389EC9118B.png" alt="" title="添加 repo 镜像国内服务器"><br><img src="/img/77C9BAB1-E831-4C0A-BA3C-A670AE8464B9.png" alt="" title="替换成功"></li>
</ul>
<p>完成后，执行操作：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod <span class="built_in">setup</span></div></pre></td></tr></table></figure></p>
<p>执行结束后代码如下图：<br><img src="/img/2016-01-12%2012-2.PNG" alt=""><br>至此，CocoaPods就完全安装结束，so easy！</p>
<h2 id="CocoaPods的使用"><a href="#CocoaPods的使用" class="headerlink" title="CocoaPods的使用"></a>CocoaPods的使用</h2><h3 id="1-新建Podfile文件"><a href="#1-新建Podfile文件" class="headerlink" title="1.新建Podfile文件"></a>1.新建Podfile文件</h3><p>使用时需要在你的项目根目录下新建一个名为Podfile的文件，将依赖的库名字依次列在文件中即可<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">promote:</span> lhl$ cd <span class="regexp">/Users/</span>chengmei<span class="regexp">/Desktop/</span>Test </div><div class="line"><span class="string">promote:</span>Test lhl$ touch Podfile</div></pre></td></tr></table></figure></p>
<p>这时候，在你的工程文件中就新建了一个名为Podfile的文件。</p>
<h3 id="2-编辑Podfile文件"><a href="#2-编辑Podfile文件" class="headerlink" title="2.编辑Podfile文件"></a>2.编辑Podfile文件</h3><p>用文本编辑器打开刚才新建的Podfile文件，此时的文件应是空白的，Podfile 文件的格式应该类似以下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">platform <span class="symbol">:ios</span>, <span class="string">'7.0'</span></div><div class="line">pod <span class="string">'AFNetworking'</span>， <span class="string">'&gt; 3.0.4'</span></div><div class="line">pod <span class="string">'LCTabBarController'</span>， <span class="string">'&gt; 1.2.2'</span></div><div class="line">pod <span class="string">'LCBannerView'</span></div></pre></td></tr></table></figure></p>
<p><strong>注意</strong><br><em>*</em>a. platform 那一行，ios 三个字母都要小写，而且与前面的冒号之间不能有间隔。<br>b. 后面的版本号也可以不写，但是有些开源库对版本是有要求的，比如要在 iOS 7.0 以上才能运行，遇到这样的开源库就需要写上版本号。<br>c. platform 下面就是 CocoaPods 需要集成的开源库，根据你的需要确定集成成些库。</p>
<hr>
<h3 id="3-查找所需要的类库"><a href="#3-查找所需要的类库" class="headerlink" title="3.查找所需要的类库"></a>3.查找所需要的类库</h3><p>例如，我们需要在工程文件中添加AFNetworking，首先需要在 CocoaPods 里面先搜索是否有需要的库，在 Terminal 中输入：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">pod search AFNetworking</span></div></pre></td></tr></table></figure></p>
<p>所显示代码如下：<br><img src="/img/0BDE439B-CD6B-4A34-A7EE-2ED5C450AAFA.png" alt=""><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">pod</span> <span class="string">'AFNetworking'</span>, <span class="string">'&gt; 3.0.4'</span></div></pre></td></tr></table></figure></p>
<p>就是需要我们在Podfile文件里面写的,把它复制，粘贴进去，并保存。</p>
<h3 id="4-执行导入命令"><a href="#4-执行导入命令" class="headerlink" title="4.执行导入命令"></a>4.执行导入命令</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd /Users/chengmei/Desktop/Test</div><div class="line">$ pod install</div></pre></td></tr></table></figure>
<p>导入成功后，如下截图所示<br><img src="/img/2016-01-12%2012.37.59.png" alt=""><br>pod install命令执行成功后，会看到工程目录下多出CocoaPodsTest.xcworkspace、Podfile.lock文件和Pods目录。再看看刚才执行完pod install命令打印出来的内容的最后一行：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="string">!</span>](<span class="link">#</span>) Please close any current Xcode sessions and use <span class="code">`Test.xcworkspace`</span> for this project from now on.</div></pre></td></tr></table></figure></p>
<p>提示我们从现在起，我们需要使用CocoaPodsTest.xcworkspace文件来开发。</p>
<h3 id="5-第三方库更新与添加"><a href="#5-第三方库更新与添加" class="headerlink" title="5.第三方库更新与添加"></a>5.第三方库更新与添加</h3><p>当需要添加第三方库时，只需要直接在Podfile里面添加第三方库信息，在terminal里面导入执行命令：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">cd</span> /Users/chengmei/Desktop/<span class="keyword">Test</span></div><div class="line">$ pod <span class="keyword">update</span></div></pre></td></tr></table></figure></p>
<p>即可添加并更新成功。<br>至此，我们CocoaPods的安装与使用就全部结束，往后我们只需在.xcworkspace文件里面编写即可。</p>
<h2 id="遇到过的坑"><a href="#遇到过的坑" class="headerlink" title="遇到过的坑"></a>遇到过的坑</h2><ol>
<li>首先就是系统升级成10.11后，由于苹果加强了安全策略，原来的sudo gem install cocoapods命令不再起作用，在10.11以前的系统中任然适用。10.11后需要适用命令sudo gem install -n /usr/local/bin cocoapods</li>
<li><img src="/img/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-01-12%2012.31.42.png" alt=""><br>这个问题折腾我好久，最后发现是在ios, ‘7.0’这个逗号后面我多输入了一个空格。</li>
</ol>
<p>3<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[!] Invalid Podfile file: undefined local variable <span class="keyword">or</span> <span class="function"><span class="keyword">method</span> '<span class="title">en_US</span>' <span class="title">for</span> #&lt;<span class="title">Pod</span>:</span>:Podfile:<span class="number">0</span>x00000102a5d8b0&gt;. Updating CocoaPods might fix the issue.</div></pre></td></tr></table></figure></p>
<p>此错误也是常见的，原因：单引号格式，可能是手动输入导致<br>解决办法：前往 系统偏好设置 - 键盘 - 文本 - 将“使用智能引号和破折号”一项取消勾选 - 再将 Podfile 里面的单（双）引号修改一下。<br><strong><em>如果遇到了神奇的报错，执行下面的命令</em></strong></p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">$</span> sudo gem update --<span class="keyword">system</span></div><div class="line"><span class="symbol">$</span> sudo gem install cocoapods</div><div class="line"><span class="symbol">$</span> pod setup</div></pre></td></tr></table></figure>
<p>重装吧</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>1、pod install提速<br>每次执行pod install和pod update的时候，cocoapods都会默认更新一次spec仓库。这是一个比较耗时的操作。在确认spec版本库不需要更新时，给这两个命令加一个参数跳过spec版本库更新,可以明显提高这两个命令的执行速度。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pod install --<span class="keyword">verbose</span> --<span class="keyword">no</span>-repo-<span class="keyword">update</span></div><div class="line">pod <span class="keyword">update</span> --<span class="keyword">verbose</span> --<span class="keyword">no</span>-repo-<span class="keyword">update</span></div></pre></td></tr></table></figure></p>
<p>2、关于Podfile文件编辑时，第三方库版本号的各种写法<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pod ‘AFNetworking’ <span class="comment">//不显式指定依赖库版本，表示每次都获取最新版本</span></div><div class="line">pod ‘AFNetworking’, ‘<span class="number">2.0</span>’ <span class="comment">//只使用2.0版本</span></div><div class="line">pod ‘AFNetworking’, ‘\&gt;<span class="number">2.0</span>′ <span class="comment">//使用高于2.0的版本</span></div><div class="line">pod ‘AFNetworking’, ‘\&gt;=<span class="number">2.0</span>′ <span class="comment">//使用大于或等于2.0的版本</span></div><div class="line">pod ‘AFNetworking’, ‘\&lt;<span class="number">2.0</span>′ <span class="comment">//使用小于2.0的版本</span></div><div class="line">pod ‘AFNetworking’, ‘\&lt;=<span class="number">2.0</span>′ <span class="comment">//使用小于或等于2.0的版本</span></div><div class="line">pod ‘AFNetworking’, ‘&gt;<span class="number">0.1</span><span class="number">.2</span>′ <span class="comment">//使用大于等于0.1.2但小于0.2的版本，相当于&gt;=0.1.2并且&lt;0.2.0</span></div><div class="line">pod ‘AFNetworking’, ‘&gt;<span class="number">0.1</span>′ <span class="comment">//使用大于等于0.1但小于1.0的版本</span></div><div class="line">pod ‘AFNetworking’, ‘&gt;<span class="number">0</span>′ <span class="comment">//高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是CocoaPods&quot;&gt;&lt;a href=&quot;#什么是CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;什么是CocoaPods&quot;&gt;&lt;/a&gt;什么是CocoaPods&lt;/h2&gt;&lt;p&gt;CocoaPods是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具，而其本身是利用ruby的依赖管理gem进行构建的。因此，在解析整合过程中，最重要的几个gems分别是：CocoaPods/CocoaPods, CocoaPods/Core, 和 CocoaPods/Xcodeproj。&lt;br&gt;在我们的工程里面会用到JSONKit、AFNetWorking等第三方开源库，首次在工程中引入这些第三方库的时候，会涉及许多配置，尤其是在build phases和linker flags配置中过程中，会引起许多人为因素的错误。CocoaPods的出现简化了这一切，并且可以通过CocoaPods查找新的第三方库。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.zhimakaiyuan.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://www.zhimakaiyuan.com/tags/iOS/"/>
    
      <category term="工具" scheme="http://www.zhimakaiyuan.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>2015年终小结</title>
    <link href="http://www.zhimakaiyuan.com/2016/01/08/2015%E5%B9%B4%E7%BB%88%E5%B0%8F%E7%BB%93/"/>
    <id>http://www.zhimakaiyuan.com/2016/01/08/2015年终小结/</id>
    <published>2016-01-08T01:53:42.000Z</published>
    <updated>2016-12-14T02:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015年已近过去，掐指一算从2014年来公司实习到正式入职也已经一年多了，非常感谢公司对我的培养和实习导师对我的教导。<a id="more"></a>工作至今，从最开始的小课桌，到安徽和教育，最云南，到现在的北京和教育，大大小小的项目也接触了五六个。在这一年的工作时间里，个人能力得到了很大的提升，虽不能完全独当一面但也能在大的项目中按照要求及时完成发放的任务，并即使处理反馈的各种问题单。希望在新的一年里个人能力能够更进一步，得到再一次的提升，迎接更加具有挑战性的工作。<br>在这一年的时间里，接触最多的还是北京的项目。这是一项很锻炼人的项目，在项目里能够学到很多东西，掌握很多新的技能。希望在新的一年中，能够为项目做出更大的贡献，在任务不是很紧张的时候，能够学习新的技术，得以运用到工作中来。</p>
<p>#个人建议<br>1、在任务比较宽松的时候多一些技术交流类似的活动，可以让大家了解并熟悉新的技术，得以运用到工作中来。<br>2、使用团队协作工具，整个项目进度大家都能看到，让每个人更加合理规划自己的工作</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015年已近过去，掐指一算从2014年来公司实习到正式入职也已经一年多了，非常感谢公司对我的培养和实习导师对我的教导。
    
    </summary>
    
      <category term="吐槽" scheme="http://www.zhimakaiyuan.com/categories/%E5%90%90%E6%A7%BD/"/>
    
    
      <category term="随笔" scheme="http://www.zhimakaiyuan.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="碎碎念" scheme="http://www.zhimakaiyuan.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>实现iOS 9 Task Switcher动画［转载］</title>
    <link href="http://www.zhimakaiyuan.com/2015/09/08/%E5%AE%9E%E7%8E%B0iOS-9-Task-Switcher%E5%8A%A8%E7%94%BB/"/>
    <id>http://www.zhimakaiyuan.com/2015/09/08/实现iOS-9-Task-Switcher动画/</id>
    <published>2015-09-08T07:04:13.000Z</published>
    <updated>2016-12-14T02:47:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自<a href="http://tech.glowing.com/cn/" target="_blank" rel="external">http://tech.glowing.com/cn/</a><br><strong>如有侵犯，立马删除</strong><br>原文链接:<a href="http://tech.glowing.com/cn/implement-ios9-task-switcher-animation/" target="_blank" rel="external">实现iOS 9 Task Switcher动画</a></p>
<p>##升级到iOS 9以后，发现新的task switcher的动画蛮有趣的，于是就动手实现了下，最终效果如下～<br><img src="/img/demo.gif" alt="demo效果图"><br><a id="more"></a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>1    首先我们需要一个横向的scroll view，可以用UICollectionView，也可以自己实现一个。scroll view里每一页都是一张card，一屏5张card:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">｜                        |</div><div class="line">｜<span class="keyword">card</span> <span class="keyword">card</span> <span class="keyword">card</span> <span class="keyword">card</span> <span class="keyword">card</span>|</div><div class="line">｜                        |</div></pre></td></tr></table></figure>
<p>2    其次，我们需要在scrollViewDidScroll中判断每张card距离中心的距离，根据这个值来调整它的alpha，scale以及x轴的translation。</p>
<p>alpha：右边的card alpha都是1，左边的越靠左alpha越小<br>scale： 从左往右依次变大<br>translation：除了中间的card，所有的card都会右偏，而为了让中间card大部分都露出来，右边的card偏移需要比左边大<br>开工</p>
<h2 id="1-横向滚动的scroll-view"><a href="#1-横向滚动的scroll-view" class="headerlink" title="1. 横向滚动的scroll view"></a>1. 横向滚动的scroll view</h2><p>我们可以自己实现一个横向无限滚动的scroll view, 具体可以参考:<a href="http://tech.glowing.com/cn/practice-in-uiscrollview/" target="_blank" rel="external">http://tech.glowing.com/cn/practice-in-uiscrollview/</a><br>在scrollViewDidScroll中，我们提供一个delegate方法，告诉使用者每一页距离中心的位置，以便apply各种transform到这个view上，delegate方法如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@protocol</span> InfiniteScrollViewDelegate \&lt;NSObject\&gt;</div><div class="line">- (<span class="keyword">void</span>)<span class="string">updateView:</span>(UIView *)view <span class="string">withProgress:</span>(CGFloat)progress <span class="string">scrollDirection:</span>(ScrollDirection)direction;</div><div class="line"><span class="meta">@end</span></div></pre></td></tr></table></figure>
<p>说明一下progress的含义，如果一屏有5个visible views的话，那么它的值会从－2变化到2：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">|<span class="string">                   </span>|</div><div class="line">|<span class="string">-2...-1...0...1...2</span>|</div><div class="line">|<span class="string">                   </span>|</div></pre></td></tr></table></figure>
<h2 id="2-根据每一页的位置来设置它的transform"><a href="#2-根据每一页的位置来设置它的transform" class="headerlink" title="2. 根据每一页的位置来设置它的transform"></a>2. 根据每一页的位置来设置它的transform</h2><p>首先是alpha，中心右边的card alpha都是1，而左边的会越来越淡，所以我们可以这样写：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (progress \&gt;= 0)   </div><div class="line"><span class="keyword">view</span>.<span class="keyword">alpha</span> = 1;</div><div class="line">&#125; <span class="keyword">else</span> </div><div class="line"><span class="keyword">view</span>.<span class="keyword">alpha</span> = 1 - fabs(progress) * 0.2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其次是scale，由左往右依次变大：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">CGAffineTransform transform</span> = CGAffineTransformIdentity;  </div><div class="line"><span class="attribute">CGFloat scale</span> = 1 + (progress) * 0.03;  </div><div class="line"><span class="attribute">transform</span> = CGAffineTransformScale(transform, scale, scale);</div></pre></td></tr></table></figure>
<p>最后是x轴的translation，除了中间的card，所有的card都会往右偏，而为了让中间card大部分都露出来，右边的card偏移需要比左边大</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CGFloat <span class="attr">translation</span> = <span class="number">0</span>;  </div><div class="line"><span class="keyword">if</span> (progress \&gt; <span class="number">0</span>)   </div><div class="line"><span class="attr">translation</span> = fabs(progress) * SCREEN_WIDTH / <span class="number">2.2</span>;</div><div class="line">&#125; <span class="keyword">else</span> </div><div class="line"><span class="attr">translation</span> = fabs(progress) * SCREEN_WIDTH / <span class="number">15</span>;</div><div class="line">&#125;</div><div class="line"><span class="attr">transform</span> = CGAffineTransformTranslate(transform, translation, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>完整的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)updateView:(<span class="built_in">UIView</span> *)view withProgress:(<span class="built_in">CGFloat</span>)progress scrollDirection:(ScrollDirection)direction</div><div class="line">&#123;</div><div class="line">    <span class="comment">// adjust z-index of each views</span></div><div class="line">    <span class="built_in">NSMutableArray</span> *views = [[<span class="keyword">self</span>.scrollView allViews] mutableCopy];</div><div class="line">    [views sortUsingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="built_in">UIView</span> *view1, <span class="built_in">UIView</span> *view2) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> view1.tag &gt; view2.tag;</div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> views) </div><div class="line">    &#123;</div><div class="line">        [view.superview bringSubviewToFront:view];</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// alpha</span></div><div class="line"><span class="keyword">if</span> (progress &gt;= <span class="number">0</span>) </div><div class="line">&#123;</div><div class="line">    view.alpha = <span class="number">1</span>;</div><div class="line">&#125; </div><div class="line"><span class="keyword">else</span> </div><div class="line">&#123;</div><div class="line">    view.alpha = <span class="number">1</span> - fabs(progress) * <span class="number">0.2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>;    </div><div class="line"><span class="comment">// scale</span></div><div class="line"><span class="built_in">CGFloat</span> scale = <span class="number">1</span> + (progress) * <span class="number">0.03</span>;</div><div class="line">transform = <span class="built_in">CGAffineTransformScale</span>(transform, scale, scale);</div><div class="line"><span class="comment">// translation</span></div><div class="line"><span class="built_in">CGFloat</span> translation = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (progress &gt; <span class="number">0</span>) </div><div class="line">&#123;</div><div class="line">    translation = fabs(progress) * SCREEN_WIDTH / <span class="number">2.2</span>;</div><div class="line">&#125; </div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    translation = fabs(progress) * SCREEN_WIDTH / <span class="number">15</span>;</div><div class="line">&#125;</div><div class="line">transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, translation, <span class="number">0</span>);</div><div class="line">view.transform = transform;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后是完整的demo代码：<a href="https://github.com/Glow-Inc/TaskSwitcherDemo" target="_blank" rel="external">https://github.com/Glow-Inc/TaskSwitcherDemo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自&lt;a href=&quot;http://tech.glowing.com/cn/&quot;&gt;http://tech.glowing.com/cn/&lt;/a&gt;&lt;br&gt;&lt;strong&gt;如有侵犯，立马删除&lt;/strong&gt;&lt;br&gt;原文链接:&lt;a href=&quot;http://tech.glowing.com/cn/implement-ios9-task-switcher-animation/&quot;&gt;实现iOS 9 Task Switcher动画&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##升级到iOS 9以后，发现新的task switcher的动画蛮有趣的，于是就动手实现了下，最终效果如下～&lt;br&gt;&lt;img src=&quot;/img/demo.gif&quot; alt=&quot;demo效果图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.zhimakaiyuan.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="转载" scheme="http://www.zhimakaiyuan.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="iOS" scheme="http://www.zhimakaiyuan.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程</title>
    <link href="http://www.zhimakaiyuan.com/2015/08/20/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://www.zhimakaiyuan.com/2015/08/20/iOS多线程/</id>
    <published>2015-08-20T08:55:52.000Z</published>
    <updated>2016-12-14T02:48:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS多线程分为四种</p>
<ul>
<li>Pthreads</li>
<li>NSThread</li>
<li>GCD</li>
<li><p>NSOperation &amp; NSOperationQueue</p>
<a id="more"></a>
<h1 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h1><p>  POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。</p>
<p>  简单地说，这是一套在很多操作系统上都通用的多线程API，所以移植性很强（然并卵），当然在 iOS 中也是可以的。不过这是基于C语言的框架，使用起来比较酸爽啦！感受一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">pthread_t thread;</div><div class="line">//创建一个线程并自动执行</div><div class="line">pthread_create(&amp;thread, NULL, start, NULL);</div><div class="line">&#125;</div><div class="line">void *start(void *data) &#123;</div><div class="line">NSLog(@&quot;%@&quot;, [NSThread currentThread]);</div><div class="line">return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>打印并输出：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2015-07-27</span> <span class="number">23</span>:<span class="number">57:21.689</span> testThread[<span class="number">10616</span>:<span class="number">2644653</span>] </div><div class="line">&lt;NSThread: <span class="number">0</span>x7fbb<span class="number">48d33690</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS多线程分为四种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pthreads&lt;/li&gt;
&lt;li&gt;NSThread&lt;/li&gt;
&lt;li&gt;GCD&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSOperation &amp;amp; NSOperationQueue&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://www.zhimakaiyuan.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="http://www.zhimakaiyuan.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>NSCFString longValue</title>
    <link href="http://www.zhimakaiyuan.com/2015/07/21/NSCFString-longValue/"/>
    <id>http://www.zhimakaiyuan.com/2015/07/21/NSCFString-longValue/</id>
    <published>2015-07-21T09:30:32.000Z</published>
    <updated>2016-12-14T02:48:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在写一个字典数据的时候，在一个字典内有18对键值对<br><a id="more"></a><br><img src="/img/2015-07-20-1.png" alt="2015"><br>其中有一个id的值为long型的,我就觉得既然你的值是long型的，那我要取你的值不是轻轻松松么,于是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">long appID = [info[@&quot;id&quot;] longValue];</div></pre></td></tr></table></figure></p>
<p>然后当然报错了，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[__NSCFString longValue]: unrecognized selector sent to instance 0x9bf8e10</div><div class="line">Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[__NSCFString longValue]: unrecognized selector sent to instance 0x9bf8e10&apos;</div></pre></td></tr></table></figure></p>
<p>百思不得其解，不对啊，我之前用还是可以的，怎么就报错了呢。最后在stackoverflow上面找到了答案。<br>原来，@“id”所对应得值，是一个id类型的值，我们需要先将他强制转换成NSString类型的值，然后再将NSString类型的值转化成long型的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *strForId = dic[@&quot;id&quot;];</div><div class="line">long appID = [strForId longLongValue];</div></pre></td></tr></table></figure>
<p>或者直接强制转换<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> appID ＝ （<span class="keyword">long</span>)［dic[@<span class="string">"id"</span>] longValue］;</div></pre></td></tr></table></figure></p>
<p>果然再也不报错了～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天在写一个字典数据的时候，在一个字典内有18对键值对&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="http://www.zhimakaiyuan.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="http://www.zhimakaiyuan.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="http://www.zhimakaiyuan.com/2015/07/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <id>http://www.zhimakaiyuan.com/2015/07/10/我的第一篇文章/</id>
    <published>2015-07-10T09:13:45.000Z</published>
    <updated>2016-12-14T02:47:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>#Hello World！<br>好吧，暂且叫它我的第一篇吧，虽说起步晚，可是质量也不高啊。。。真不是一个用心的博主啊</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Hello World！&lt;br&gt;好吧，暂且叫它我的第一篇吧，虽说起步晚，可是质量也不高啊。。。真不是一个用心的博主啊&lt;/p&gt;

    
    </summary>
    
      <category term="纪念" scheme="http://www.zhimakaiyuan.com/categories/%E7%BA%AA%E5%BF%B5/"/>
    
    
      <category term="随笔" scheme="http://www.zhimakaiyuan.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="碎碎念" scheme="http://www.zhimakaiyuan.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
</feed>
