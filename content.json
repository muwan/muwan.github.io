{"meta":{"title":"芝麻开源","subtitle":"对大海情有独钟却又怀有敬意，很懒的一个理科男。","description":"热爱旅行想要探索世界，可惜兜里没有钱。目前是一枚iOS开发者，414457229是我建立的QQ群，目前有4人了，欢迎加入。","author":"muwan","url":"http://www.zhimakaiyuan.com"},"pages":[{"title":"","date":"2016-12-14T03:39:11.000Z","updated":"2016-12-14T02:30:45.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.zhimakaiyuan.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2016-12-14T03:39:11.000Z","updated":"2016-12-14T02:49:53.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.zhimakaiyuan.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"用Let's encrypt 免费给自己的博客加上https之小白版","slug":"https-for-lets-encrypt","date":"2016-12-17T05:47:56.000Z","updated":"2016-12-17T05:50:33.000Z","comments":true,"path":"2016/12/17/https-for-lets-encrypt/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/12/17/https-for-lets-encrypt/","excerpt":"最近公司任务不是很重，适配iOS 10 ATS 已经成为了项目这一个月的任务，杨老大负责任的把这个重担一个人扛下了，因此我等小民就只能自己去研究了，于是就寻思着给自己的博客加上ssl验证，有个小绿锁🔒 看起来确实是舒坦很多。在这里就记录下全过程。","text":"最近公司任务不是很重，适配iOS 10 ATS 已经成为了项目这一个月的任务，杨老大负责任的把这个重担一个人扛下了，因此我等小民就只能自己去研究了，于是就寻思着给自己的博客加上ssl验证，有个小绿锁🔒 看起来确实是舒坦很多。在这里就记录下全过程。 前言HTTPS目前已经成为各大主流网站的标配，未来必将成为一种趋势，很多个人博客现在也都加入了HTTPS的阵营。HTTPS好处多多，可以防止各种攻击劫持，运营商广告植入，客户传输信息泄露等问题。为了让HTTPS能够全面普及，Let’s Encrypt项目应运而生，它由互联网安全研究小组ISRG（Internet Security Research Group）提供服务，ISRG是来自美国加利福尼亚州的一个公益组织。Let’s Encrypt 得到了 Mozilla、Cisco和 Chrome 等众多公司和机构的支持。 关于Let’s EncryotLet’s Encrypt 是一个新的 CA，他能够提供一种非常容易的方式来获取和安装免费的 TLS/SSL 证书，从而在 web 服务器上启用 HTTPS 加密。他通过提供软件客户端 letsencrypt 来简化这个过程，它企图自动完成大部分所需的必要步骤。当前，Let’s Encrypt 仍然处在公开测试阶段，他整个获取和安装证书的流程只在 Apache 服务器上实现了全部自动化。然而 Let’s Encrypt 也可以很容易的在其他不同的服务器上获取和安装免费的 SSL 证书。 申请 Let’s Encrypt 证书不仅免费、代码开源，而且配置简单，不过每次申请只有90天的有效期，但可以通过脚本定期更新，配置好之后一劳永逸。 下面就开始来一起看看吧～ 第一步：创建 LET’S ENCRYPT 账号（如何你没有的话),并生成CSR文件为了区分其他，我们现创建一个文件夹，用来单独存放账号、证书和key 12mkdir sslcd ssl Let’s Encrypt使用一个私钥来进行账号的创建与登陆，因此我们需要使用openssl创建一个account.key。首先我们需要看下我们的openssl的安装目录，并记录下openssl.cnf 文件的地址。 1openssl version –a 从这里我们可以看到当出openssl的安装路径 123456OpenSSL 1.0.2g 1 Mar 2016built on: reproducible build, date unspecifiedplatform: debian-amd64options: bn(64,64) rc4(16x,int) des(idx,cisc,16,int) blowfish(idx) compiler: cc -I. -I.. -I../include -fPIC -DOPENSSL_PIC -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -m64 -DL_ENDIAN -g -O2 -fdebug-prefix-map=/build/openssl-wIGtVG/openssl-1.0.2g=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -Wl,-Bsymbolic-functions -Wl,-z,relro -Wa,--noexecstack -Wall -DMD32_REG_T=int -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM -DECP_NISTZ256_ASMOPENSSLDIR: \"/usr/lib/ssl\" //这个就是我们需要的openssl的路径了 这一步完成后，我们开始我们的第一步 创建Let’s Encrypt私钥首先进入我们刚刚的ssl 文件夹，然后生成私钥12cd sslopenssl genrsa 4096 &gt; account.key 创建CSR(Certificate Signing Request，证书签名请求) 文件 ACME协议 (Let’s Encrypt所使用的) 需要一个csr文件，用来进行证书签名和证书更新。 将需要加密的域名加到下面的代码中，目前一张证书最多可以加密 100 个域名，注意命令行中的域名换成你自己的域名： 123openssl genrsa 4096 &gt; domain.keyopenssl req -new -sha256 -key domain.key -subj \"/\" -reqexts SAN -config &lt;(cat /usr/lib/ssl/openssl.cnf &lt;(printf \"[SAN]\\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com\")) &gt; domain.csr 注意：openssl.cnf 文件的位置可能会因为linux版本的不同而有变，我们只需要在上一步中的openssl 路径后面加上/openssl.cnf 现在我们已经生成了csr和私钥，接下来就到了比较纠结的一步了，需要证明你拥有该域名 配置域名验证CA 在签发 DV（Domain Validation）证书时，需要验证域名所有权。传统 CA 的验证方式一般是往 admin@youmail.com 发验证邮件，而 Let’s Encrypt 是在你的服务器上生成一个随机验证文件，再通过创建 CSR 时指定的域名访问，如果可以访问则表明你对这个域名有控制权。 首先创建用于存放验证文件的目录，然后通过 “.well-known/acme-challenge/“ 这个URL来访问到验证文件. 注意: Let’s Encrypt 会对你的服务器做一次http请求来进行验证，因此你需要保证80端口能够访问： 1mkdir -p /var/www/challenges 然后配置一个 HTTP 服务，以 Nginx 为例：(注意：这里的端口是80，不是443） 1234567891011121314151617//这个是新增加的一个servrserver &#123;listen 80;server_name yoursite.com www.yoursite.com;if ( $request_uri !~ \"/.well-known/acme-challenge/*\" ) &#123; # 让 Let's Encrypt 成功访问到验证文件不受 301 影响return 301 https://yoursite.com$request_uri; # 注意进行301重定向到https，否则通过http仍能访问你的站点&#125;location /.well-known/acme-challenge/ &#123;alias /var/www/challenges/;try_files $uri =404;&#125;#...你的其他配置&#125; 这个验证服务以后更新证书还要用到，需要一直保留。 获取网站证书先回到我们的ssl目录，然后把 acme-tiny 脚本保存到 ssl 目录 12345cdcd sslwget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.pysudo chmod +x acme_tiny.py python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /var/www/challenges/ &gt; ./signed.crt 如果一切正常，当前目录下就会生成一个 signed.crt，这就是申请好的证书文件。 安装证书证书生成后，就可以把它配置在web 服务器上了，需要注意的是，Nginx需要追加一个Let’s Encrypt的中间证书，在 Nginx 配置中，需要把中间证书和网站证书合在一起：``wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pemcat signed.crt intermediate.pem &gt; chained.pem 123最终，修改 Nginx 中有关证书的配置并 reload 服务即可：## 修改 Nginx 中有关证书的配置并 reload 服务 server {listen 443;server_name yoursite.com, www.yoursite.com; ssl on;ssl_certificate /path/to/chained.pem;ssl_certificate_key /path/to/domain.key;ssl_session_timeout 5m;ssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA;ssl_session_cache shared:SSL:50m;ssl_prefer_server_ciphers on; #…你的其他配置} server { listen 80;server_name yoursite.com www.yoursite.com; if ( $request_uri !~ “/.well-known/acme-challenge/*” ) { # 让 Let’s Encrypt 成功访问到验证文件不受 301 影响return 301 https://yoursite.com$request_uri; # 注意进行301重定向到https，否则通过http仍能访问你的站点} location /.well-known/acme-challenge/ {alias /var/www/challenges/;try_files $uri =404;} #…你的其他配置} 大功告成好了，现在就能重启你的nginx1nginx -s reload 后续恭喜！你的网站已经使用上了HTTPS。 但Let’s Encrypt 证书有效期只有90天, 所以需要定期更新。现在只需要写一个更新脚本并把它放到定时任务中即可。 在ssl的文件夹内进行如下操作1234cdcd ssltouch renew_cert.shvi renew_cert.sh 然后在renew_cert.sh中输入12345#!/usr/bin/shpython /root/ssl/acme_tiny.py --account-key /root/ssl/account.key --csr /root/ssl/domain.csr --acme-dir /var/www/challenges/ &gt; /tmp/signed.crt || exitwget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pemcat /tmp/signed.crt intermediate.pem &gt; /root/ssl/chained.pemservice nginx reload 定时任务可以设置为每个月执行一次：10 0 1 * * /root/ssl/acme-tiny/renew_cert.sh 2&gt;&gt; /var/log/acme_tine.log 以上就是整个的全过程了。欢迎享受HTTPS之旅～","categories":[],"tags":[{"name":"https","slug":"https","permalink":"http://www.zhimakaiyuan.com/tags/https/"},{"name":"瞎折腾","slug":"瞎折腾","permalink":"http://www.zhimakaiyuan.com/tags/瞎折腾/"}]},{"title":"Xcode8在Objective-C中集成Charts 3.0（全是坑！！！）","slug":"Xcode8-Uses-Charts-Objective-C","date":"2016-12-06T09:04:26.000Z","updated":"2016-12-16T08:08:21.000Z","comments":true,"path":"2016/12/06/Xcode8-Uses-Charts-Objective-C/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/12/06/Xcode8-Uses-Charts-Objective-C/","excerpt":"用cocoapods集成Charts说多了都是泪，全是坑！不过全都搞好以后，画图表还是很方便的。","text":"用cocoapods集成Charts说多了都是泪，全是坑！不过全都搞好以后，画图表还是很方便的。 不知咋滴，一大早起来后把项目clean了一下，然后把pod文件全删了，重新运行1pod install 然后再clean，居然好了。。。下面记录下踩坑的整个过程 Charts 是何方神圣Charts是一套非常漂亮的开源图表组件，它是MPAndroidChart在苹果端的移植版本，同时支持iOS/tvOS/OSX平台，开源地址Github。 同时，Charts是用 Swift 语言编写的，能够在 Swift 和 Objc 工程中使用。 使用环境 Xcode 8.0 / Swift 3.0 (如果要支持 Swift 2.3 ，请查看 Charts 2.3) iOS &gt;= 8.0 tvOS &gt;= 9.0 macOS &gt;= 10.11 使用方法本文使用的是通过cocopods 来安装的，中间的过程有点曲折 通过 cocoapods 集成如果项目还未使用cocoapods，可用终端在根目录下输入1pod init 然后在项目的 Podfile 文件中添加 Charts1pod 'Charts', '~&gt; 3.0' 如果不出意外的话，会在安装过程中报个小错 1[!] Pods written in Swift can only be integrated as frameworks; add `use_frameworks!` to your Podfile or target to opt into using it. The Swift Pod being used is: Charts 恭喜踩到了第一个坑 为什么呢原来根据苹果的相关政策，在 Swift项目中苹果将不允许你私自包含静态库了，因此我们的解决办法是,在 podfile 文件中 添加这么一句12pod 'Charts', '~&gt; 3.0'use_frameworks! use_frameworks！选项是告诉 CocoaPods 使用 framework 而不是静态库。这在 Swift 项目中是必选。 完成之后，我们开始导入 导入库在项目的根目录下，输入1pod install 静待几分钟后，会有提示倒入成功这时候，我们需要打开 xcworkspace 文件,注意哦，是 xcworkspace 不再是原来的 xcodeproj文件了 因为我们的项目是 OC 的，而 Charts 是用 Swift 编写的，所以需要创建一个桥接文件完成后，会有提示是否需要桥接，点击 Create Bridging Header 执行完这一步后，如果有报错之类的，可以先把项目 clean 一下 敲黑板 这是一道送分题，千万不能忘 接着在桥接文件 项目名-Bridging-Header.h 中，写上要引用的 Swift 头文件。1@import Charts; 大功告成进入测试阶段在ViewController.m中加入如下代码：12345678910111213141516171819202122232425262728293031323334353637383940- (void)viewDidLoad &#123;[super viewDidLoad];self.view.backgroundColor = [UIColor colorWithRed:0.184 green:1.000 blue:0.738 alpha:1.000];lineView = [[LineChartView alloc]initWithFrame:CGRectMake(0, self.view.bounds.size.height / 3.0f,[UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height / 3.0)];lineView.backgroundColor = [UIColor colorWithRed:0.184 green:1.000 blue:0.738 alpha:1.000];[self.view addSubview:lineView];lineView.dragEnabled = YES;//是否拖拽，lineView.drawGridBackgroundEnabled = NO;//绘制网格背景lineView.scaleXEnabled = NO;lineView.pinchZoomEnabled = NO;lineView.descriptionText = @\"每月收入支出图\";//X轴设置ChartXAxis *xAxis = lineView.xAxis;xAxis.labelPosition = XAxisLabelPositionBothSided;//X轴样式xAxis.drawLabelsEnabled = YES;//X轴是否需要绘制文字xAxis.drawAxisLineEnabled = YES;//X轴绘制xAxis.drawGridLinesEnabled = NO;//X轴网格绘制xAxis.axisLineWidth = 0.4f;//数轴宽度[xAxis setLabelCount:10 force:NO];//X轴数量一般默认是6个//Y轴设置ChartYAxis *yAxis = lineView.leftAxis;yAxis.spaceTop = .5f;//Y轴顶部的最大值的百分比yAxis.labelFont = [UIFont fontWithName:@\"HelveticaNeue-Light\" size:12.f];[yAxis setLabelCount:5 force:NO];//Y轴坐标个数yAxis.labelTextColor = [UIColor blackColor];//Y轴坐标文字颜色yAxis.labelPosition = YAxisLabelPositionInsideChart;yAxis.drawGridLinesEnabled = NO;//Y轴网格yAxis.axisLineColor = UIColor.blackColor;lineView.rightAxis.enabled = NO;int count = 30;double range = 10;[self setDataCount:count range:range];[lineView animateWithXAxisDuration:3 yAxisDuration:3];// Do any additional setup after loading the view, typically from a nib.&#125; 然后随机配置一下数据，就能看到两条曲线了完美🤗demo地址：ChartsDemo 参考博客Cocoapods 安装参考Swift静态库参考","categories":[{"name":"吐槽","slug":"吐槽","permalink":"http://www.zhimakaiyuan.com/categories/吐槽/"},{"name":"技术","slug":"吐槽/技术","permalink":"http://www.zhimakaiyuan.com/categories/吐槽/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"}]},{"title":"Add SSH Key to Your Remote Client","slug":"add-SSH-Key-to-Your-remote-clint","date":"2016-11-03T05:26:30.000Z","updated":"2016-12-14T02:41:29.000Z","comments":true,"path":"2016/11/03/add-SSH-Key-to-Your-remote-clint/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/11/03/add-SSH-Key-to-Your-remote-clint/","excerpt":"前段时间，买了Vultr家的VPS用作shadowsocks，最近突然很感兴趣，于是捣鼓了下，每次登录的时候都需要输入密码有点麻烦，就找到了如何用ssh登录的方法。","text":"前段时间，买了Vultr家的VPS用作shadowsocks，最近突然很感兴趣，于是捣鼓了下，每次登录的时候都需要输入密码有点麻烦，就找到了如何用ssh登录的方法。 准备工作Mac、VPS（安装的是ubuntu 16.0） 工作原理ssh除了使用密码验证外，还提供了一种公私密钥的验证方式。客户端生成一个私钥，并生成一个与之对应的公钥，然后将公钥上传到服务器上。 开始准备 在本地机器创建公钥在客户端生成私钥、公钥（注意，在Mac 上完成）1ssh-keygen -t rsa -C 'your email' 然后一路回车，生成你自己的密钥对，成功截图如下 将公钥复制到ssh服务器将前一步骤生成的公钥~/id_rsa.pub文件，复制到ssh服务器对应用户下的~/.ssh/authorized_keys文件,可以有多种方式，这里只介绍常用的一种。12brew install ssh-copy-idssh-copy-id username@hostname #将username和hostname替换为你的ssh服务器用户名和IP 当ssh服务器username用户目录下尚未有.ssh目录时使用此方式1cat ~/.ssh/id_rsa.pub | ssh username@hostname \"mkdir ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys\" 通用方式1234scp ~/.ssh/id_rsa.pub username@hostname:~/ #将公钥文件复制至ssh服务器ssh username@hostname #使用用户名和密码方式登录至ssh服务器mkdir .ssh #若.ssh目录已存在，可省略此步cat id_rsa.pub &gt;&gt; .ssh/authorized_keys #将公钥文件id_rsa.pub文件内容追加到authorized_keys文件 快捷登录完成以上步骤后，即可使用以下命令直接登录ssh服务器，妈妈再也不用担心你记不住密码了以后登录ssh，只需要在你的Mac上输入 username@hostname``` 即可不用输入密码啦～123456789# 思考即使这样，我们还是需要输入远程服务器的ip地址，有时候真的脑容量不够啊，怎么办，怎么办，怎么办！！！没关系，我们还能实现本地一条命令就能登录**ssh本身也提供了一种快捷的方式来解决这个问题，往~/.ssh/config配置文件添加你的ssh服务器信息即可**在本地可客户端（你的Mac）输入 vim ~/.ssh/config1然后在终端输入 i 开始插入如下内容： Host name#自定义别名HostName hostname #替换为你的ssh服务器ip或domainPort 22 #ssh服务器端口，默认为22User root #ssh服务器用户名IdentityFile ~/.ssh/id_rsa #第一个步骤生成的公钥文件对应的私钥文件1234按下ESC，然后依次输入 :wq保存并退出最终，我们只需要在终端输入 ssh name```就能远程登录我们的VPS啦～ 写在最后这篇文章多亏了我们的黄小贱同学","categories":[{"name":"技术","slug":"技术","permalink":"http://www.zhimakaiyuan.com/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://www.zhimakaiyuan.com/tags/工具/"},{"name":"VPS","slug":"VPS","permalink":"http://www.zhimakaiyuan.com/tags/VPS/"}]},{"title":"Mac上搭建shadowsocks服务","slug":"Mac上搭建shadowsocks服务","date":"2016-10-27T06:27:24.000Z","updated":"2016-12-14T02:42:17.000Z","comments":true,"path":"2016/10/27/Mac上搭建shadowsocks服务/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/10/27/Mac上搭建shadowsocks服务/","excerpt":"之前看着教程自己也乱七八糟的搭建了一个ss的服务端，但是感觉一团糟，于是趁着自己有时间，就重新搭建一下，顺便好好记录下搭建的过程，方便自己，也希望能给其他刚接触的一点帮助。首先我自己的是一台Mac，所以主要记录的也是Mac上的操作，我的vps买的是搬瓦工19.99$的，目前使用感觉还行。","text":"之前看着教程自己也乱七八糟的搭建了一个ss的服务端，但是感觉一团糟，于是趁着自己有时间，就重新搭建一下，顺便好好记录下搭建的过程，方便自己，也希望能给其他刚接触的一点帮助。首先我自己的是一台Mac，所以主要记录的也是Mac上的操作，我的vps买的是搬瓦工19.99$的，目前使用感觉还行。 写在最前面：为什么翻墙？应该每个人都有自己的原因，总的来说，还是”赵家人“管得太宽，各种访问不了目前使用的工具也是种类繁多，很多免费的不稳定，速度慢，使用起来也不见得安全，付费的虽然好点，但是依然是使用的别人的代理服务器。因此，还是我们自己来搭一个吧，至于为什么选择ss，主要是觉得搭建比较方便，而且安全性想对较好 需要准备哪些电脑（Mac）、vps（ubuntu 16 ＊ 64） shadowsocks 服务器安装登陆你的远程服务器打开Mac自带的终端ssh root@你的ip -p 你的ssh端口，若没有特殊分配，一般都是22 更新源软件1root@localhost:~# sudo apt-get update 更新完成后，会有提示 安装PIP环境root@localhost:~# sudo apt-get install python-pip由于原作者已经不再更新 pip 下的源代码，故不再使用 pip 安装 Shadowsocks。 安装shadowsocks pip install shadowsocks 由于原作者已经不再更新 pip 下的源代码，故不再使用 pip 安装 Shadowsocks，而是改为下载 Github 的 master 分支来安装。如果在一段时间后，版本升级了，则先卸载，并再次执行本脚本就可以升级为最新版。这里采用了秋水逸冰的博客，采用该一键安装 Python 版 Shadowsocks 的最新版，同时安装了 Python 包管理工具 pip。 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 安装完成后，脚本提示如下12345678910Congratulations, shadowsocks install completed!Your Server IP:your_server_ipYour Server Port:your_server_portYour Password:your_passwordYour Local IP:127.0.0.1Your Local Port:1080Your Encryption Method:aes-256-cfbWelcome to visit:https://teddysun.com/342.htmlEnjoy it! 卸载方法1./shadowsocks.sh uninstall 进入配置1vi /etc/shadowsocks.json 键盘上按下「i」键，进入Insert mode 单用户配置文件12345678910&#123;\"server\":\"0.0.0.0\",\"server_port\":8989,\"local_address\":\"127.0.0.1\",\"local_port\":1080,\"password\":\"yourpassword\",\"timeout\":300,\"method\":\"aes-256-cfb\",\"fast_open\": false&#125; 多用户配置文件123456789101112131415&#123;\"server\":\"0.0.0.0\",\"local_address\":\"127.0.0.1\",\"local_port\":1080,\"port_password\":&#123;\"8989\":\"password0\",\"9001\":\"password1\",\"9002\":\"password2\",\"9003\":\"password3\",\"9004\":\"password4\"&#125;,\"timeout\":300,\"method\":\"aes-256-cfb\",\"fast_open\": false&#125; 这里需要注意,””{}不要漏了配置完成之后，先按「esc」退出，然后按一下「：」冒号键进入「Last line mode」，例如： : w filename （输入 「w filename」将文章以指定的文件名filename保存） : wq (输入「wq」，存盘并退出vi) : q! (输入q!， 不存盘强制退出vi)这里我们直接存盘并退出，「：wq」 使用命令1234启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status 参考链接http://jiji262.github.io/2016/09/28/setup-Shadowsocks-on-ubuntu-1604/https://teddysun.com/342.html","categories":[{"name":"技术","slug":"技术","permalink":"http://www.zhimakaiyuan.com/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://www.zhimakaiyuan.com/tags/工具/"},{"name":"翻墙","slug":"翻墙","permalink":"http://www.zhimakaiyuan.com/tags/翻墙/"},{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://www.zhimakaiyuan.com/tags/Shadowsocks/"}]},{"title":"Effective-Objective-C 2.0笔记","slug":"Effective-Objective-C-2-0笔记","date":"2016-10-10T02:51:38.000Z","updated":"2016-12-14T02:41:47.000Z","comments":true,"path":"2016/10/10/Effective-Objective-C-2-0笔记/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/10/10/Effective-Objective-C-2-0笔记/","excerpt":"上一个博客写了Effective Objective-C 2.0 的总的概览，这一章准备记录一下本书中提到的编写高质量iOS 与 OS X 代码的52个有效方法","text":"上一个博客写了Effective Objective-C 2.0 的总的概览，这一章准备记录一下本书中提到的编写高质量iOS 与 OS X 代码的52个有效方法 第1条:了解 Objective-C 语言的起源第2条:在类的头文件中尽量少引入其他文件第3条:多用字面量语法，少用与之等价的方法第4条:多用类型常量，少用 #define 预处理指令第5条:用枚举表示状态、选项、状态码 第6条:理解“属性”这一概念第7条:在对象内部尽量直接访问实例变量第8条:理解“对象等同性”这一概念第9条:以“类族模式”隐藏实现细节第10条:在既有类中使用关联对象存放自定义数据第11条:理解 obje_msgSend 的作用第12条:理解消息转发机制第13条:用“方法调配技术”测试“黑盒方法”第14条:理解“类对象”的用意 第15条:用前缀避免命名空间冲突第16条:提供“全能初始化方法”第17条:实现 description 方法第18条:尽量使用不可变对象第19条:使用清晰而协调的命名方式第20条:为私有方法名加前缀第21条:理解 Objective-C 错误模型第22条:理解 NSCopying 第23条:通过委托与数据源协议进行对象间通信第24条:将类的实现代码分散到便于管理的数个分类之中第25条:总是为第三方类的分类名称加前缀第26条:勿在分类中声明属性第27条:使用 “class-continuation 分类”隐藏实现细节第28条:通过协议提供匿名对象 第29条:理解引用计数第30条:以 ARC 简化引用计数第31条:","categories":[{"name":"学习","slug":"学习","permalink":"http://www.zhimakaiyuan.com/categories/学习/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"},{"name":"笔记","slug":"笔记","permalink":"http://www.zhimakaiyuan.com/tags/笔记/"}]},{"title":"Effective-Objective-C 2.0笔记（概览）","slug":"Effective-Objective-C-2-0笔记（概览）","date":"2016-02-01T07:19:23.000Z","updated":"2016-12-14T02:41:57.000Z","comments":true,"path":"2016/02/01/Effective-Objective-C-2-0笔记（概览）/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/02/01/Effective-Objective-C-2-0笔记（概览）/","excerpt":"一直想说要读完这本书，结果在咸鱼老湿的督促下，还是没能看完，努力还是要靠自己啊，今天正好有时间，就先把标题里在这里。我们先定个小目标，比方说，先把这52个有效方法写出来，以后再慢慢填充。编写高质量iOS与OS X代码的52个有效方法。","text":"一直想说要读完这本书，结果在咸鱼老湿的督促下，还是没能看完，努力还是要靠自己啊，今天正好有时间，就先把标题里在这里。我们先定个小目标，比方说，先把这52个有效方法写出来，以后再慢慢填充。编写高质量iOS与OS X代码的52个有效方法。本书分为七章，分别是 熟悉 Objective-C通论该语言的核心概念 对象、消息、运行期对象之间能够关联与交互，这是面向对象语言的重要特征。贲张讲述这些特性，并深入研究代码在运行期的行为。 接口与 API 设计很少有那种写完就不再复用的代码。即使代码不向更多人公开，也依然有可能用在自己的多个项目中。本章讲解如何编写与 Objective-C 搭配得宜的类。 协议与分类协议与分类是两个需要掌握的重要语言特性。若运用得当，则可以令代码易读、易维护且少出错。本章将帮助读者精通这两个概念。 内存管理Objective-C 语言以引用计数来管理内存，这令许多初学者纠结，要是用过以“垃圾收集器” (garbage collector)来管理内存的语言，那么更会如此。“自动引用计数”机制缓解了此问题，不过使用时有很多重要的注意事项，以确保对象模型正确，不致内存泄漏。本章提醒读者注意内存管理中易犯的错误。 块与大中枢派发苹果公司引入了“块”这一概念，其余法类似于 C 语言扩展中的“闭包”(closure)。在 Objective-C 语言中，我们通常采用块来实现一些原来需要很多样板代码才能完成的事情，块还能实现“代码分离”(code separation)。“大中枢派发”(Grand Central Dispatch,GCD) 提供了一套用于多线程环境的简单接口。“块”可视为GCD的任务，根据系统资源状况，这些任务也许能并发执行。本章将教会读者如何充分运用这两项核心技术。 系统框架大家通常会用 Objective-C 开开发Mac OS X 或 iOS 程序。在这两种情况下都有一套完整的系统框架可供使用，前者名为 Cocoa ，后者名为 Cocoa Touch。本章将总览这些框架，并深入研究其中某些类。 共有52个有效方法，会在下一章博客中写出来","categories":[{"name":"学习","slug":"学习","permalink":"http://www.zhimakaiyuan.com/categories/学习/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"},{"name":"笔记","slug":"笔记","permalink":"http://www.zhimakaiyuan.com/tags/笔记/"}]},{"title":"开始健身","slug":"开始健身","date":"2016-01-15T04:03:40.000Z","updated":"2016-12-14T02:47:24.000Z","comments":true,"path":"2016/01/15/开始健身/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/01/15/开始健身/","excerpt":"","text":"####终于开始健身了，今天将是第三次去了，还是矫正体型，看来健身的道路很漫长啊。距离目标身材还很遥远，加油吧，骚年！","categories":[{"name":"生活","slug":"生活","permalink":"http://www.zhimakaiyuan.com/categories/生活/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://www.zhimakaiyuan.com/tags/碎碎念/"},{"name":"健身","slug":"健身","permalink":"http://www.zhimakaiyuan.com/tags/健身/"}]},{"title":"CocoaPods的使用与安装","slug":"CocoaPods的使用与安装","date":"2016-01-12T05:07:11.000Z","updated":"2016-12-14T02:41:39.000Z","comments":true,"path":"2016/01/12/CocoaPods的使用与安装/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/01/12/CocoaPods的使用与安装/","excerpt":"什么是CocoaPodsCocoaPods是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具，而其本身是利用ruby的依赖管理gem进行构建的。因此，在解析整合过程中，最重要的几个gems分别是：CocoaPods/CocoaPods, CocoaPods/Core, 和 CocoaPods/Xcodeproj。在我们的工程里面会用到JSONKit、AFNetWorking等第三方开源库，首次在工程中引入这些第三方库的时候，会涉及许多配置，尤其是在build phases和linker flags配置中过程中，会引起许多人为因素的错误。CocoaPods的出现简化了这一切，并且可以通过CocoaPods查找新的第三方库。","text":"什么是CocoaPodsCocoaPods是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具，而其本身是利用ruby的依赖管理gem进行构建的。因此，在解析整合过程中，最重要的几个gems分别是：CocoaPods/CocoaPods, CocoaPods/Core, 和 CocoaPods/Xcodeproj。在我们的工程里面会用到JSONKit、AFNetWorking等第三方开源库，首次在工程中引入这些第三方库的时候，会涉及许多配置，尤其是在build phases和linker flags配置中过程中，会引起许多人为因素的错误。CocoaPods的出现简化了这一切，并且可以通过CocoaPods查找新的第三方库。 CocoaPods的工作原理CocoaPods的原理是将所有的依赖库都放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个 .a文件即可。 CocoaPods的安装上面已经提到了，CocoaPods是利用Ruby的依赖管理gem进行构建，因此安装CocoaPods需要在ruby的环境下。 1.Ruby环境搭建Mac OS是自带ruby环境的，但是保险起见，还是需要更新一下。a.查看当前ruby版本打开Mac的terminal 输入ruby -v代码如下12$ ruby -vruby 2.0.0p645 (2015-04-13 revision 50299) [universal.x86_64-darwin15](#) b.更换ruby源终端输入如下命令（ruby的软件源rubygems.org因为使用的亚马逊的云服务，所以被墙了，需要更新一下ruby的源，国内常用的镜像服务有淘宝阿里云的，山东理工大学的,一般使用淘宝的）gem sources –remove https://rubygems.org/gem sources -a https://ruby.taobao.org/gem sources -l （用来检查使用替换镜像位置成功）代码如下123456789$ gem sources --remove https://rubygems.org/https://rubygems.org/ removed from sources$ gem sources -a https://ruby.taobao.org/https://ruby.taobao.org/ added to sources$ gem sources -l*** CURRENT SOURCES ***http://rubygems-china.oss.aliyuncs.comhttps://ruby.taobao.org/ 2.升级gemsudo gem update –system升级成功后，代码如下 3.下载安装CocoaPods安装CocoaPods（OS X 10.11以前） sudo gem install cocoapods安装CocoaPods（10.11后苹果升级了安全策略） sudo gem install -n /usr/local/bin cocoapods安装更新后，会有 gem installed提示 所有的项目的Podspec文件都托管在https://github.com/CocoaPods/Specs。第一次执行pod setup时，CocoaPods会将这些podspec索引文件更新到本地的 /.cocoapods/目录下，这个索引文件比较大，有80M左右。所以第一次更新时非常慢，一般更新了将近1个小时才完成。一个叫akinliu的朋友在gitcafe和oschina上建立了CocoaPods索引库的镜像，因为gitcafe和oschina都是国内的服务器，所以在执行索引更新操作时，会快很多。如下操作可以将CocoaPods设置成使用gitcafe镜像：1.移除原有服务器 pod repo remove master2.添加境内服务器（建议使用第一个） pod repo add master https://gitcafe.com/akuandev/Specs.git pod repo add master http://git.oschina.net/akuandev/Specs.git(开源中国较慢)使用及截图如下 完成后，执行操作：1pod setup 执行结束后代码如下图：至此，CocoaPods就完全安装结束，so easy！ CocoaPods的使用1.新建Podfile文件使用时需要在你的项目根目录下新建一个名为Podfile的文件，将依赖的库名字依次列在文件中即可12promote: lhl$ cd /Users/chengmei/Desktop/Test promote:Test lhl$ touch Podfile 这时候，在你的工程文件中就新建了一个名为Podfile的文件。 2.编辑Podfile文件用文本编辑器打开刚才新建的Podfile文件，此时的文件应是空白的，Podfile 文件的格式应该类似以下：1234platform :ios, '7.0'pod 'AFNetworking'， '&gt; 3.0.4'pod 'LCTabBarController'， '&gt; 1.2.2'pod 'LCBannerView' 注意*a. platform 那一行，ios 三个字母都要小写，而且与前面的冒号之间不能有间隔。b. 后面的版本号也可以不写，但是有些开源库对版本是有要求的，比如要在 iOS 7.0 以上才能运行，遇到这样的开源库就需要写上版本号。c. platform 下面就是 CocoaPods 需要集成的开源库，根据你的需要确定集成成些库。 3.查找所需要的类库例如，我们需要在工程文件中添加AFNetworking，首先需要在 CocoaPods 里面先搜索是否有需要的库，在 Terminal 中输入：1pod search AFNetworking 所显示代码如下：1pod 'AFNetworking', '&gt; 3.0.4' 就是需要我们在Podfile文件里面写的,把它复制，粘贴进去，并保存。 4.执行导入命令12$ cd /Users/chengmei/Desktop/Test$ pod install 导入成功后，如下截图所示pod install命令执行成功后，会看到工程目录下多出CocoaPodsTest.xcworkspace、Podfile.lock文件和Pods目录。再看看刚才执行完pod install命令打印出来的内容的最后一行：1[!](#) Please close any current Xcode sessions and use `Test.xcworkspace` for this project from now on. 提示我们从现在起，我们需要使用CocoaPodsTest.xcworkspace文件来开发。 5.第三方库更新与添加当需要添加第三方库时，只需要直接在Podfile里面添加第三方库信息，在terminal里面导入执行命令：12$ cd /Users/chengmei/Desktop/Test$ pod update 即可添加并更新成功。至此，我们CocoaPods的安装与使用就全部结束，往后我们只需在.xcworkspace文件里面编写即可。 遇到过的坑 首先就是系统升级成10.11后，由于苹果加强了安全策略，原来的sudo gem install cocoapods命令不再起作用，在10.11以前的系统中任然适用。10.11后需要适用命令sudo gem install -n /usr/local/bin cocoapods 这个问题折腾我好久，最后发现是在ios, ‘7.0’这个逗号后面我多输入了一个空格。 31[!] Invalid Podfile file: undefined local variable or method 'en_US' for #&lt;Pod::Podfile:0x00000102a5d8b0&gt;. Updating CocoaPods might fix the issue. 此错误也是常见的，原因：单引号格式，可能是手动输入导致解决办法：前往 系统偏好设置 - 键盘 - 文本 - 将“使用智能引号和破折号”一项取消勾选 - 再将 Podfile 里面的单（双）引号修改一下。如果遇到了神奇的报错，执行下面的命令 123$ sudo gem update --system$ sudo gem install cocoapods$ pod setup 重装吧 更多1、pod install提速每次执行pod install和pod update的时候，cocoapods都会默认更新一次spec仓库。这是一个比较耗时的操作。在确认spec版本库不需要更新时，给这两个命令加一个参数跳过spec版本库更新,可以明显提高这两个命令的执行速度。12pod install --verbose --no-repo-updatepod update --verbose --no-repo-update 2、关于Podfile文件编辑时，第三方库版本号的各种写法123456789pod ‘AFNetworking’ //不显式指定依赖库版本，表示每次都获取最新版本pod ‘AFNetworking’, ‘2.0’ //只使用2.0版本pod ‘AFNetworking’, ‘\\&gt;2.0′ //使用高于2.0的版本pod ‘AFNetworking’, ‘\\&gt;=2.0′ //使用大于或等于2.0的版本pod ‘AFNetworking’, ‘\\&lt;2.0′ //使用小于2.0的版本pod ‘AFNetworking’, ‘\\&lt;=2.0′ //使用小于或等于2.0的版本pod ‘AFNetworking’, ‘&gt;0.1.2′ //使用大于等于0.1.2但小于0.2的版本，相当于&gt;=0.1.2并且&lt;0.2.0pod ‘AFNetworking’, ‘&gt;0.1′ //使用大于等于0.1但小于1.0的版本pod ‘AFNetworking’, ‘&gt;0′ //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本","categories":[{"name":"技术","slug":"技术","permalink":"http://www.zhimakaiyuan.com/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"},{"name":"工具","slug":"工具","permalink":"http://www.zhimakaiyuan.com/tags/工具/"}]},{"title":"2015年终小结","slug":"2015年终小结","date":"2016-01-08T01:53:42.000Z","updated":"2016-12-14T02:47:16.000Z","comments":true,"path":"2016/01/08/2015年终小结/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/01/08/2015年终小结/","excerpt":"2015年已近过去，掐指一算从2014年来公司实习到正式入职也已经一年多了，非常感谢公司对我的培养和实习导师对我的教导。","text":"2015年已近过去，掐指一算从2014年来公司实习到正式入职也已经一年多了，非常感谢公司对我的培养和实习导师对我的教导。工作至今，从最开始的小课桌，到安徽和教育，最云南，到现在的北京和教育，大大小小的项目也接触了五六个。在这一年的工作时间里，个人能力得到了很大的提升，虽不能完全独当一面但也能在大的项目中按照要求及时完成发放的任务，并即使处理反馈的各种问题单。希望在新的一年里个人能力能够更进一步，得到再一次的提升，迎接更加具有挑战性的工作。在这一年的时间里，接触最多的还是北京的项目。这是一项很锻炼人的项目，在项目里能够学到很多东西，掌握很多新的技能。希望在新的一年中，能够为项目做出更大的贡献，在任务不是很紧张的时候，能够学习新的技术，得以运用到工作中来。 #个人建议1、在任务比较宽松的时候多一些技术交流类似的活动，可以让大家了解并熟悉新的技术，得以运用到工作中来。2、使用团队协作工具，整个项目进度大家都能看到，让每个人更加合理规划自己的工作","categories":[{"name":"吐槽","slug":"吐槽","permalink":"http://www.zhimakaiyuan.com/categories/吐槽/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.zhimakaiyuan.com/tags/随笔/"},{"name":"碎碎念","slug":"碎碎念","permalink":"http://www.zhimakaiyuan.com/tags/碎碎念/"}]},{"title":"实现iOS 9 Task Switcher动画［转载］","slug":"实现iOS-9-Task-Switcher动画","date":"2015-09-08T07:04:13.000Z","updated":"2016-12-14T02:47:33.000Z","comments":true,"path":"2015/09/08/实现iOS-9-Task-Switcher动画/","link":"","permalink":"http://www.zhimakaiyuan.com/2015/09/08/实现iOS-9-Task-Switcher动画/","excerpt":"本文转载自http://tech.glowing.com/cn/如有侵犯，立马删除原文链接:实现iOS 9 Task Switcher动画 ##升级到iOS 9以后，发现新的task switcher的动画蛮有趣的，于是就动手实现了下，最终效果如下～","text":"本文转载自http://tech.glowing.com/cn/如有侵犯，立马删除原文链接:实现iOS 9 Task Switcher动画 ##升级到iOS 9以后，发现新的task switcher的动画蛮有趣的，于是就动手实现了下，最终效果如下～ 思路1 首先我们需要一个横向的scroll view，可以用UICollectionView，也可以自己实现一个。scroll view里每一页都是一张card，一屏5张card: 123｜ |｜card card card card card|｜ | 2 其次，我们需要在scrollViewDidScroll中判断每张card距离中心的距离，根据这个值来调整它的alpha，scale以及x轴的translation。 alpha：右边的card alpha都是1，左边的越靠左alpha越小scale： 从左往右依次变大translation：除了中间的card，所有的card都会右偏，而为了让中间card大部分都露出来，右边的card偏移需要比左边大开工 1. 横向滚动的scroll view我们可以自己实现一个横向无限滚动的scroll view, 具体可以参考:http://tech.glowing.com/cn/practice-in-uiscrollview/在scrollViewDidScroll中，我们提供一个delegate方法，告诉使用者每一页距离中心的位置，以便apply各种transform到这个view上，delegate方法如下： 123@protocol InfiniteScrollViewDelegate \\&lt;NSObject\\&gt;- (void)updateView:(UIView *)view withProgress:(CGFloat)progress scrollDirection:(ScrollDirection)direction;@end 说明一下progress的含义，如果一屏有5个visible views的话，那么它的值会从－2变化到2： 123| ||-2...-1...0...1...2|| | 2. 根据每一页的位置来设置它的transform首先是alpha，中心右边的card alpha都是1，而左边的会越来越淡，所以我们可以这样写： 12345if (progress \\&gt;= 0) view.alpha = 1;&#125; else view.alpha = 1 - fabs(progress) * 0.2;&#125; 其次是scale，由左往右依次变大： 123CGAffineTransform transform = CGAffineTransformIdentity; CGFloat scale = 1 + (progress) * 0.03; transform = CGAffineTransformScale(transform, scale, scale); 最后是x轴的translation，除了中间的card，所有的card都会往右偏，而为了让中间card大部分都露出来，右边的card偏移需要比左边大 1234567CGFloat translation = 0; if (progress \\&gt; 0) translation = fabs(progress) * SCREEN_WIDTH / 2.2;&#125; else translation = fabs(progress) * SCREEN_WIDTH / 15;&#125;transform = CGAffineTransformTranslate(transform, translation, 0); 完整的实现： 12345678910111213141516171819202122232425262728293031323334353637383940-(void)updateView:(UIView *)view withProgress:(CGFloat)progress scrollDirection:(ScrollDirection)direction&#123; // adjust z-index of each views NSMutableArray *views = [[self.scrollView allViews] mutableCopy]; [views sortUsingComparator:^NSComparisonResult(UIView *view1, UIView *view2) &#123; return view1.tag &gt; view2.tag; &#125;]; for (UIView *view in views) &#123; [view.superview bringSubviewToFront:view]; &#125;// alphaif (progress &gt;= 0) &#123; view.alpha = 1;&#125; else &#123; view.alpha = 1 - fabs(progress) * 0.2;&#125;CGAffineTransform transform = CGAffineTransformIdentity; // scaleCGFloat scale = 1 + (progress) * 0.03;transform = CGAffineTransformScale(transform, scale, scale);// translationCGFloat translation = 0;if (progress &gt; 0) &#123; translation = fabs(progress) * SCREEN_WIDTH / 2.2;&#125; else&#123; translation = fabs(progress) * SCREEN_WIDTH / 15;&#125;transform = CGAffineTransformTranslate(transform, translation, 0);view.transform = transform;&#125; 最后是完整的demo代码：https://github.com/Glow-Inc/TaskSwitcherDemo","categories":[{"name":"技术","slug":"技术","permalink":"http://www.zhimakaiyuan.com/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"},{"name":"转载","slug":"转载","permalink":"http://www.zhimakaiyuan.com/tags/转载/"}]},{"title":"iOS多线程","slug":"iOS多线程","date":"2015-08-20T08:55:52.000Z","updated":"2016-12-14T02:48:04.000Z","comments":true,"path":"2015/08/20/iOS多线程/","link":"","permalink":"http://www.zhimakaiyuan.com/2015/08/20/iOS多线程/","excerpt":"iOS多线程分为四种 Pthreads NSThread GCD NSOperation &amp; NSOperationQueue","text":"iOS多线程分为四种 Pthreads NSThread GCD NSOperation &amp; NSOperationQueue Pthreads POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。 简单地说，这是一套在很多操作系统上都通用的多线程API，所以移植性很强（然并卵），当然在 iOS 中也是可以的。不过这是基于C语言的框架，使用起来比较酸爽啦！感受一下： 123456789- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;pthread_t thread;//创建一个线程并自动执行pthread_create(&amp;thread, NULL, start, NULL);&#125;void *start(void *data) &#123;NSLog(@&quot;%@&quot;, [NSThread currentThread]);return NULL;&#125; 打印并输出：122015-07-27 23:57:21.689 testThread[10616:2644653] &lt;NSThread: 0x7fbb48d33690&gt;&#123;number = 2, name = (null)&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://www.zhimakaiyuan.com/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"}]},{"title":"NSCFString longValue","slug":"NSCFString-longValue","date":"2015-07-21T09:30:32.000Z","updated":"2016-12-14T02:48:14.000Z","comments":true,"path":"2015/07/21/NSCFString-longValue/","link":"","permalink":"http://www.zhimakaiyuan.com/2015/07/21/NSCFString-longValue/","excerpt":"昨天在写一个字典数据的时候，在一个字典内有18对键值对","text":"昨天在写一个字典数据的时候，在一个字典内有18对键值对其中有一个id的值为long型的,我就觉得既然你的值是long型的，那我要取你的值不是轻轻松松么,于是1long appID = [info[@&quot;id&quot;] longValue]; 然后当然报错了，12-[__NSCFString longValue]: unrecognized selector sent to instance 0x9bf8e10Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[__NSCFString longValue]: unrecognized selector sent to instance 0x9bf8e10&apos; 百思不得其解，不对啊，我之前用还是可以的，怎么就报错了呢。最后在stackoverflow上面找到了答案。原来，@“id”所对应得值，是一个id类型的值，我们需要先将他强制转换成NSString类型的值，然后再将NSString类型的值转化成long型的。 12NSString *strForId = dic[@&quot;id&quot;];long appID = [strForId longLongValue]; 或者直接强制转换1long appID ＝ （long)［dic[@\"id\"] longValue］; 果然再也不报错了～","categories":[{"name":"其他","slug":"其他","permalink":"http://www.zhimakaiyuan.com/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://www.zhimakaiyuan.com/tags/其他/"}]},{"title":"我的第一篇文章","slug":"我的第一篇文章","date":"2015-07-10T09:13:45.000Z","updated":"2016-12-14T02:47:47.000Z","comments":true,"path":"2015/07/10/我的第一篇文章/","link":"","permalink":"http://www.zhimakaiyuan.com/2015/07/10/我的第一篇文章/","excerpt":"","text":"#Hello World！好吧，暂且叫它我的第一篇吧，虽说起步晚，可是质量也不高啊。。。真不是一个用心的博主啊","categories":[{"name":"纪念","slug":"纪念","permalink":"http://www.zhimakaiyuan.com/categories/纪念/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.zhimakaiyuan.com/tags/随笔/"},{"name":"碎碎念","slug":"碎碎念","permalink":"http://www.zhimakaiyuan.com/tags/碎碎念/"}]}]}