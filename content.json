{"meta":{"title":"芝麻开源","subtitle":"对大海情有独钟却又怀有敬意，很懒的一个理科男。","description":"热爱旅行想要探索世界，可惜兜里没有钱。目前是一枚iOS开发者，414457229是我建立的QQ群，目前有4人了，欢迎加入。","author":"muwan","url":"http://www.zhimakaiyuan.com"},"pages":[{"title":"","date":"2016-12-14T03:39:11.000Z","updated":"2016-12-14T02:49:53.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.zhimakaiyuan.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2016-12-14T03:39:11.000Z","updated":"2016-12-14T02:30:45.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.zhimakaiyuan.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"(转载)细说GCD（Grand Central Dispatch）如何用","slug":"GCD-and-how-to-use","date":"2016-12-26T00:50:22.000Z","updated":"2016-12-26T01:10:54.000Z","comments":true,"path":"2016/12/26/GCD-and-how-to-use/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/12/26/GCD-and-how-to-use/","excerpt":"文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。文中的Demo在这里 https://github.com/ming1016/GCDDemo 对着文章试着来调demo体会更深哦，细细嚼消化好:)","text":"文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。文中的Demo在这里 https://github.com/ming1016/GCDDemo 对着文章试着来调demo体会更深哦，细细嚼消化好:)博客原文链接:https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8#gcd%E6%A6%82%E8%A6%81 GCD（Grand Central Dispatch） 介绍GCD属于系统级的线程管理，在Dispatch queue中执行需要执行的任务性能非常的高。GCD这块已经开源，地址http://libdispatch.macosforge.org。GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。 GCD概要 和operation queue一样都是基于队列的并发编程API，他们通过集中管理大家协同使用的线程池。 公开的5个不同队列：运行在主线程中的main queue，3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），以及一个优先级更低的后台队列Background Priority Queue（用于I/O） 可创建自定义队列：串行或并列队列。自定义一般放在Default Priority Queue和Main Queue里。 操作是在多线程上还是单线程主要是看队列的类型和执行方法，并行队列异步执行才能在多线程，并行队列同步执行就只会在主线程执行了 基本概念 系统标准两个队列 1234//全局队列，一个并行的队列dispatch_get_global_queue//主队列，主线程中的唯一队列，一个串行队列dispatch_get_main_queue 自定义队列 1234//串行队列dispatch_queue_create(&quot;com.starming.serialqueue&quot;, DISPATCH_QUEUE_SERIAL)//并行队列dispatch_queue_create(&quot;com.starming.concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT) 同步异步线程创建 1234//同步线程dispatch_sync(..., ^(block))//异步线程dispatch_async(..., ^(block)) 队列（dispatch queue） Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。 Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。 Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。系统提供四个全局并发队列，这四个队列有着对应的优先级，用户是不能够创建全局队列的，只能获取。 12dipatch_queue_t queue;queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0); user create queue：创建自己定义的队列，可以用dispatch_queue_create函数，函数有两个参数，第一个自定义的队列名，第二个参数是队列类型，默认NULL或者DISPATCH_QUEUE_SERIAL的是串行，参数为DISPATCH_QUEUE_CONCURRENT为并行队列。 12dispatch_queue_t queuequeue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT); 自定义队列的优先级：可以通过dipatch_queue_attr_make_with_qos_class或dispatch_set_target_queue方法设置队列的优先级 12345678//dipatch_queue_attr_make_with_qos_classdispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, -1);dispatch_queue_t queue = dispatch_queue_create(&quot;com.starming.gcddemo.qosqueue&quot;, attr);//dispatch_set_target_queuedispatch_queue_t queue = dispatch_queue_create(&quot;com.starming.gcddemo.settargetqueue&quot;,NULL); //需要设置优先级的queuedispatch_queue_t referQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0); //参考优先级dispatch_set_target_queue(queue, referQueue); //设置queue和referQueue的优先级一样 dispatch_set_target_queue：可以设置优先级，也可以设置队列层级体系，比如让多个串行和并行队列在统一一个串行队列里串行执行，如下 12345678910111213141516171819dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL);dispatch_queue_t firstQueue = dispatch_queue_create(&quot;com.starming.gcddemo.firstqueue&quot;, DISPATCH_QUEUE_SERIAL);dispatch_queue_t secondQueue = dispatch_queue_create(&quot;com.starming.gcddemo.secondqueue&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_set_target_queue(firstQueue, serialQueue);dispatch_set_target_queue(secondQueue, serialQueue);dispatch_async(firstQueue, ^&#123; NSLog(@&quot;1&quot;); [NSThread sleepForTimeInterval:3.f];&#125;);dispatch_async(secondQueue, ^&#123; NSLog(@&quot;2&quot;); [NSThread sleepForTimeInterval:2.f];&#125;);dispatch_async(secondQueue, ^&#123; NSLog(@&quot;3&quot;); [NSThread sleepForTimeInterval:1.f];&#125;); 队列类型队列默认是串行的，如果设置改参数为NULL会按串行处理，只能执行一个单独的block，队列也可以是并行的，同一时间执行多个block123456789101112- (id)init;&#123; self = [super init]; if (self != nil) &#123; NSString *label = [NSString stringWithFormat:@&quot;%@.isolation.%p&quot;, [self class], self]; self.isolationQueue = dispatch_queue_create([label UTF8String], 0); label = [NSString stringWithFormat:@&quot;%@.work.%p&quot;, [self class], self]; self.workQueue = dispatch_queue_create([label UTF8String], 0); &#125; return self;&#125; 5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为 QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。 QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。 QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。 QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。 示例：后台加载显示图片12345678910override func viewDidLoad() &#123; super.viewDidLoad() dispatch_async(dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0)) &#123; // 将工作从主线程转移到全局队列中，这是dispatch_async调用，异步提交保证调用线程会继续执行下去，这样viewDidLoad在主线程上能够更早完成， let overlayImage = self.faceOverlayImageFromImage(self.image) dispatch_async(dispatch_get_main_queue()) &#123; // 新图完成，把一个闭包加入主线程用来更新UIImageView，只有在主线程能操作UIKit。 self.fadeInNewImage(overlayImage) // 更新UI &#125; &#125;&#125; 何时使用何种队列类型 主队列（顺序）：队列中有任务完成需要更新UI时，dispatch_after在这种类型中使用。 并发队列：用来执行与UI无关的后台任务，dispatch_sync放在这里，方便等待任务完成进行后续处理或和dispatch barrier同步。dispatch groups放在这里也不错。 自定义顺序队列：顺序执行后台任务并追踪它时。这样做同时只有一个任务在执行可以防止资源竞争。dipatch barriers解决读写锁问题的放在这里处理。dispatch groups也是放在这里。 可以使用下面的方法简化QoS等级参数的写法1234567891011121314151617181920212223var GlobalMainQueue: dispatch_queue_t &#123; return dispatch_get_main_queue()&#125;var GlobalUserInteractiveQueue: dispatch_queue_t &#123; return dispatch_get_global_queue(Int(QOS_CLASS_USER_INTERACTIVE.value), 0)&#125;var GlobalUserInitiatedQueue: dispatch_queue_t &#123; return dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0)&#125;var GlobalUtilityQueue: dispatch_queue_t &#123; return dispatch_get_global_queue(Int(QOS_CLASS_UTILITY.value), 0)&#125;var GlobalBackgroundQueue: dispatch_queue_t &#123; return dispatch_get_global_queue(Int(QOS_CLASS_BACKGROUND.value), 0)&#125;//使用起来就是这样，易读而且容易看出在使用哪个队列dispatch_async(GlobalUserInitiatedQueue) &#123; let overlayImage = self.faceOverlayImageFromImage(self.image) dispatch_async(GlobalMainQueue) &#123; self.fadeInNewImage(overlayImage) &#125;&#125; dispatch_once用法dispatch_once_t要是全局或static变量，保证dispatch_once_t只有一份实例12345678910+ (UIColor *)boringColor;&#123; static UIColor *color; //只运行一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; color = [UIColor colorWithRed:0.380f green:0.376f blue:0.376f alpha:1.000f]; &#125;); return color;&#125; dispatch_async设计一个异步的API调用dispatch_async()，这个调用放在API的方法或函数中做。让API的使用者设置一个回调处理队列123456789- (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler;&#123; dispatch_async(self.isolationQueue, ^(void)&#123; // do actual processing here dispatch_async(self.resultQueue, ^(void)&#123; handler(YES); &#125;); &#125;);&#125; 可以避免界面会被一些耗时的操作卡死，比如读取网络数据，大数据IO，还有大量数据的数据库读写，这时需要在另一个线程中处理，然后通知主线程更新界面，GCD使用起来比NSThread和NSOperation方法要简单方便。12345678910111213141516171819//代码框架dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 耗时的操作 dispatch_async(dispatch_get_main_queue(), ^&#123; // 更新界面 &#125;);&#125;);//下载图片的示例dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSURL * url = [NSURL URLWithString:@&quot;http://avatar.csdn.net/2/C/D/1_totogo2010.jpg&quot;]; NSData * data = [[NSData alloc]initWithContentsOfURL:url]; UIImage *image = [[UIImage alloc]initWithData:data]; if (data != nil) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; &#125;); &#125;&#125;); dispatch_after延后执行dispatch_after只是延时提交block，不是延时立刻执行。12345678- (void)foo&#123; double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC)); dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123; [self bar]; &#125;);&#125; 范例，实现一个推迟出现弹出框提示，比如说提示用户评价等功能。12345678910111213func showOrHideNavPrompt() &#123; let delayInSeconds = 1.0 let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(delayInSeconds * Double(NSEC_PER_SEC))) // 在这里声明推迟的时间 dispatch_after(popTime, GlobalMainQueue) &#123; // 等待delayInSeconds将闭包异步到主队列 let count = PhotoManager.sharedManager.photos.count if count &gt; 0 &#123; self.navigationItem.prompt = nil &#125; else &#123; self.navigationItem.prompt = \"Add photos with faces to Googlyify them!\" &#125; &#125;&#125; 例子中的dispatch time的参数，可以先看看函数原型1dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta ); 第一个参数为DISPATCH_TIME_NOW表示当前。第二个参数的delta表示纳秒，一秒对应的纳秒为1000000000，系统提供了一些宏来简化123#define NSEC_PER_SEC 1000000000ull //每秒有多少纳秒#define USEC_PER_SEC 1000000ull //每秒有多少毫秒#define NSEC_PER_USEC 1000ull //每毫秒有多少纳秒 这样如果要表示一秒就可以这样写123dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);dispatch_time(DISPATCH_TIME_NOW, 1000 * USEC_PER_SEC);dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * NSEC_PER_USEC); dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁Dispatch Barrier确保提交的闭包是指定队列中在特定时段唯一在执行的一个。在所有先于Dispatch Barrier的任务都完成的情况下这个闭包才开始执行。轮到这个闭包时barrier会执行这个闭包并且确保队列在此过程不会执行其它任务。闭包完成后队列恢复。需要注意dispatch_barrier_async只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和dispatch_sync一样1234567891011121314151617181920212223242526272829303132333435363738//创建队列self.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT);//改变setter- (void)setCount:(NSUInteger)count forKey:(NSString *)key&#123; key = [key copy]; //确保所有barrier都是async异步的 dispatch_barrier_async(self.isolationQueue, ^()&#123; if (count == 0) &#123; [self.counts removeObjectForKey:key]; &#125; else &#123; self.counts[key] = @(count); &#125; &#125;);&#125;- (void)dispatchBarrierAsyncDemo &#123; //防止文件读写冲突，可以创建一个串行队列，操作都在这个队列中进行，没有更新数据读用并行，写用串行。 dispatch_queue_t dataQueue = dispatch_queue_create(&quot;com.starming.gcddemo.dataqueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(dataQueue, ^&#123; [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;read data 1&quot;); &#125;); dispatch_async(dataQueue, ^&#123; NSLog(@&quot;read data 2&quot;); &#125;); //等待前面的都完成，在执行barrier后面的 dispatch_barrier_async(dataQueue, ^&#123; NSLog(@&quot;write data 1&quot;); [NSThread sleepForTimeInterval:1]; &#125;); dispatch_async(dataQueue, ^&#123; [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;read data 3&quot;); &#125;); dispatch_async(dataQueue, ^&#123; NSLog(@&quot;read data 4&quot;); &#125;);&#125; swift示例12345678910111213141516171819202122//使用dispatch_queue_create初始化一个并发队列。第一个参数遵循反向DNS命名习惯，方便描述，第二个参数是指出是并发还是顺序。private let concurrentPhotoQueue = dispatch_queue_create(\"com.raywenderlich.GooglyPuff.photoQueue\", DISPATCH_QUEUE_CONCURRENT)func addPhoto(photo: Photo) &#123; dispatch_barrier_async(concurrentPhotoQueue) &#123; // 将写操作加入到自定义的队列。开始执行时这个就是队列中唯一的一个在执行的任务。 self._photos.append(photo) // barrier能够保障不会和其他任务同时进行。 dispatch_async(GlobalMainQueue) &#123; // 涉及到UI所以这个通知应该在主线程中，所以分派另一个异步任务到主队列中。 self.postContentAddedNotification() &#125; &#125;&#125;//上面是解决了写可能发生死锁，下面是使用dispatch_sync解决读时可能会发生的死锁。var photos: [Photo] &#123; var photosCopy: [Photo]! dispatch_sync(concurrentPhotoQueue) &#123; // 同步调度到concurrentPhotoQueue队列执行读操作 photosCopy = self._photos // 保存 &#125; return photosCopy&#125;//这样读写问题都解决了。 都用异步处理避免死锁，异步的缺点在于调试不方便，但是比起同步容易产生死锁这个副作用还算小的。 dispatch_apply进行快速迭代类似for循环，但是在并发队列的情况下dispatch_apply会并发执行block任务。12345678910111213for (size_t y = 0; y &lt; height; ++y) &#123; for (size_t x = 0; x &lt; width; ++x) &#123; // Do something with x and y here &#125;&#125;//因为可以并行执行，所以使用dispatch_apply可以运行的更快- (void)dispatchApplyDemo &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_apply(10, concurrentQueue, ^(size_t i) &#123; NSLog(@&quot;%zu&quot;,i); &#125;); NSLog(@&quot;The end&quot;); //这里有个需要注意的是，dispatch_apply这个是会阻塞主线程的。这个log打印会在dispatch_apply都结束后才开始执行&#125; dispatch_apply能避免线程爆炸，因为GCD会管理并发123456789101112131415161718- (void)dealWiththreadWithMaybeExplode:(BOOL)explode &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT); if (explode) &#123; //有问题的情况，可能会死锁 for (int i = 0; i &lt; 999 ; i++) &#123; dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;wrong %d&quot;,i); //do something hard &#125;); &#125; &#125; else &#123; //会优化很多，能够利用GCD管理 dispatch_apply(999, concurrentQueue, ^(size_t i)&#123; NSLog(@&quot;correct %zu&quot;,i); //do something hard &#125;); &#125;&#125; 示例：1234567891011121314151617181920212223242526272829func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) &#123; var storedError: NSError! var downloadGroup = dispatch_group_create() let addresses = [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] dispatch_apply(UInt(addresses.count), GlobalUserInitiatedQueue) &#123; i in let index = Int(i) let address = addresses[index] let url = NSURL(string: address) dispatch_group_enter(downloadGroup) let photo = DownloadPhoto(url: url!) &#123; image, error in if let error = error &#123; storedError = error &#125; dispatch_group_leave(downloadGroup) &#125; PhotoManager.sharedManager.addPhoto(photo) &#125; dispatch_group_notify(downloadGroup, GlobalMainQueue) &#123; if let completion = completion &#123; completion(error: storedError) &#125; &#125;&#125; Block组合Dispatch_groupsdispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。 当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。 第一种使用dispatch_group_wait的swift的例子：1234567891011121314151617181920212223242526272829func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) &#123; dispatch_async(GlobalUserInitiatedQueue) &#123; // 因为dispatch_group_wait会租塞当前进程，所以要使用dispatch_async将整个方法要放到后台队列才能够保证主线程不被阻塞 var storedError: NSError! var downloadGroup = dispatch_group_create() // 创建一个dispatch group for address in [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] &#123; let url = NSURL(string: address) dispatch_group_enter(downloadGroup) // dispatch_group_enter是通知dispatch group任务开始了，dispatch_group_enter和dispatch_group_leave是成对调用，不然程序就崩溃了。 let photo = DownloadPhoto(url: url!) &#123; image, error in if let error = error &#123; storedError = error &#125; dispatch_group_leave(downloadGroup) // 保持和dispatch_group_enter配对。通知任务已经完成 &#125; PhotoManager.sharedManager.addPhoto(photo) &#125; dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER) // dispatch_group_wait等待所有任务都完成直到超时。如果任务完成前就超时了，函数会返回一个非零值，可以通过返回值判断是否超时。也可以用DISPATCH_TIME_FOREVER表示一直等。 dispatch_async(GlobalMainQueue) &#123; // 这里可以保证所有图片任务都完成，然后在main queue里加入完成后要处理的闭包，会在main queue里执行。 if let completion = completion &#123; // 执行闭包内容 completion(error: storedError) &#125; &#125; &#125;&#125; oc例子1234567891011121314- (void)dispatchGroupWaitDemo &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); //在group中添加队列的block dispatch_group_async(group, concurrentQueue, ^&#123; [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;1&quot;); &#125;); dispatch_group_async(group, concurrentQueue, ^&#123; NSLog(@&quot;2&quot;); &#125;); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@&quot;go on&quot;);&#125; 第二种使用dispatch_group_notify的swift的例子：123456789101112131415161718192021222324252627func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) &#123; // 不用加dispatch_async，因为没有阻塞主进程 var storedError: NSError! var downloadGroup = dispatch_group_create() for address in [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] &#123; let url = NSURL(string: address) dispatch_group_enter(downloadGroup) let photo = DownloadPhoto(url: url!) &#123; image, error in if let error = error &#123; storedError = error &#125; dispatch_group_leave(downloadGroup) &#125; PhotoManager.sharedManager.addPhoto(photo) &#125; dispatch_group_notify(downloadGroup, GlobalMainQueue) &#123; // dispatch_group_notify和dispatch_group_wait的区别就是是异步执行闭包的，当dispatch groups中没有剩余的任务时闭包才执行。这里是指明在主队列中执行。 if let completion = completion &#123; completion(error: storedError) &#125; &#125;&#125; oc例子1234567891011121314151617181920212223242526272829303132//dispatch_group_notify- (void)dispatchGroupNotifyDemo &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, concurrentQueue, ^&#123; NSLog(@&quot;1&quot;); &#125;); dispatch_group_async(group, concurrentQueue, ^&#123; NSLog(@&quot;2&quot;); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@&quot;end&quot;); &#125;); NSLog(@&quot;can continue&quot;);&#125;//dispatch_group_wait- (void)dispatchGroupWaitDemo &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); //在group中添加队列的block dispatch_group_async(group, concurrentQueue, ^&#123; [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;1&quot;); &#125;); dispatch_group_async(group, concurrentQueue, ^&#123; NSLog(@&quot;2&quot;); &#125;); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@&quot;can continue&quot;);&#125; 如何对现有API使用dispatch_group_t12345678910111213141516171819202122232425262728293031323334//给Core Data的-performBlock:添加groups。组合完成任务后使用dispatch_group_notify来运行一个block即可。- (void)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block&#123; if (group == NULL) &#123; [self performBlock:block]; &#125; else &#123; dispatch_group_enter(group); [self performBlock:^()&#123; block(); dispatch_group_leave(group); &#125;]; &#125;&#125;//NSURLConnection也可以这样做+ (void)withGroup:(dispatch_group_t)group sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler&#123; if (group == NULL) &#123; [self sendAsynchronousRequest:request queue:queue completionHandler:handler]; &#125; else &#123; dispatch_group_enter(group); [self sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *error)&#123; handler(response, data, error); dispatch_group_leave(group); &#125;]; &#125;&#125; 注意事项 dispatch_group_async等价于dispatch_group_enter() 和 dispatch_group_leave()的组合。 dispatch_group_enter() 必须运行在 dispatch_group_leave() 之前。 dispatch_group_enter() 和 dispatch_group_leave() 需要成对出现的 Dispatch Block队列执行任务都是block的方式， 创建block 1234567891011121314- (void)createDispatchBlock &#123; //normal way dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_block_t block = dispatch_block_create(0, ^&#123; NSLog(@&quot;run block&quot;); &#125;); dispatch_async(concurrentQueue, block); //QOS way dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INITIATED, -1, ^&#123; NSLog(@&quot;run qos block&quot;); &#125;); dispatch_async(concurrentQueue, qosBlock);&#125; dispatch_block_wait：可以根据dispatch block来设置等待时间，参数DISPATCH_TIME_FOREVER会一直等待block结束 123456789101112- (void)dispatchBlockWaitDemo &#123; dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_block_t block = dispatch_block_create(0, ^&#123; NSLog(@&quot;star&quot;); [NSThread sleepForTimeInterval:5.f]; NSLog(@&quot;end&quot;); &#125;); dispatch_async(serialQueue, block); //设置DISPATCH_TIME_FOREVER会一直等到前面任务都完成 dispatch_block_wait(block, DISPATCH_TIME_FOREVER); NSLog(@&quot;ok, now can go on&quot;);&#125; dispatch_block_notify：可以监视指定dispatch block结束，然后再加入一个block到队列中。三个参数分别为，第一个是需要监视的block，第二个参数是需要提交执行的队列，第三个是待加入到队列中的block 1234567891011121314- (void)dispatchBlockNotifyDemo &#123; dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_block_t firstBlock = dispatch_block_create(0, ^&#123; NSLog(@&quot;first block start&quot;); [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;first block end&quot;); &#125;); dispatch_async(serialQueue, firstBlock); dispatch_block_t secondBlock = dispatch_block_create(0, ^&#123; NSLog(@&quot;second block run&quot;); &#125;); //first block执行完才在serial queue中执行second block dispatch_block_notify(firstBlock, serialQueue, secondBlock);&#125; dispatch_block_cancel：iOS8后GCD支持对dispatch block的取消 123456789101112131415- (void)dispatchBlockCancelDemo &#123; dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_block_t firstBlock = dispatch_block_create(0, ^&#123; NSLog(@&quot;first block start&quot;); [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;first block end&quot;); &#125;); dispatch_block_t secondBlock = dispatch_block_create(0, ^&#123; NSLog(@&quot;second block run&quot;); &#125;); dispatch_async(serialQueue, firstBlock); dispatch_async(serialQueue, secondBlock); //取消secondBlock dispatch_block_cancel(secondBlock);&#125; 使用dispatch block object（调度块）在任务执行前进行取消dispatch block object可以为队列中的对象设置示例，下载图片中途进行取消123456789101112131415161718192021222324252627282930313233343536373839404142func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) &#123; var storedError: NSError! let downloadGroup = dispatch_group_create() var addresses = [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] addresses += addresses + addresses // 扩展address数组，复制3份 var blocks: [dispatch_block_t] = [] // 一个保存block的数组 for i in 0 ..&lt; addresses.count &#123; dispatch_group_enter(downloadGroup) let block = dispatch_block_create(DISPATCH_BLOCK_INHERIT_QOS_CLASS) &#123; // 创建一个block，block的标志是DISPATCH_BLOCK_INHERIT_QOS_CLASS let index = Int(i) let address = addresses[index] let url = NSURL(string: address) let photo = DownloadPhoto(url: url!) &#123; image, error in if let error = error &#123; storedError = error &#125; dispatch_group_leave(downloadGroup) &#125; PhotoManager.sharedManager.addPhoto(photo) &#125; blocks.append(block) dispatch_async(GlobalMainQueue, block) // 把这个block放到GlobalMainQueue上异步调用。因为全局队列是一个顺序队列所以方便取消对象block，同时可以保证下载任务在downloadPhotosWithCompletion返回后才开始执行。 &#125; for block in blocks[3 ..&lt; blocks.count] &#123; let cancel = arc4random_uniform(2) // 随机返回一个整数，会返回0或1 if cancel == 1 &#123; dispatch_block_cancel(block) // 如果是1就取消block，这个只能发生在block还在队列中并没有开始的情况下。因为把block已经放到了GlobalMainQueue中，所以这个地方会先执行，执行完了才会执行block。 dispatch_group_leave(downloadGroup) // 因为已经dispatch_group_enter了，所以取消时也要将其都leave掉。 &#125; &#125; dispatch_group_notify(downloadGroup, GlobalMainQueue) &#123; if let completion = completion &#123; completion(error: storedError) &#125; &#125;&#125; Dispatch IO 文件操作dispatch io读取文件的方式类似于下面的方式，多个线程去读取文件的切片数据，对于大的数据文件这样会比单线程要快很多。123dispatch_async(queue,^&#123;/*read 0-99 bytes*/&#125;);dispatch_async(queue,^&#123;/*read 100-199 bytes*/&#125;);dispatch_async(queue,^&#123;/*read 200-299 bytes*/&#125;); dispatch_io_create：创建dispatch io dispatch_io_set_low_water：指定切割文件大小 dispatch_io_read：读取切割的文件然后合并。 苹果系统日志API里用到了这个技术，可以在这里查看：https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c12345678910111213141516171819202122232425262728293031323334353637383940pipe_q = dispatch_queue_create(&quot;PipeQ&quot;, NULL);//创建pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, pipe_q, ^(int err)&#123; close(fd);&#125;);*out_fd = fdpair[1];//设置切割大小dispatch_io_set_low_water(pipe_channel, SIZE_MAX);dispatch_io_read(pipe_channel, 0, SIZE_MAX, pipe_q, ^(bool done, dispatch_data_t pipedata, int err)&#123; if (err == 0) &#123; size_t len = dispatch_data_get_size(pipedata); if (len &gt; 0) &#123; //对每次切块数据的处理 const char *bytes = NULL; char *encoded; uint32_t eval; dispatch_data_t md = dispatch_data_create_map(pipedata, (const void **)&amp;bytes, &amp;len); encoded = asl_core_encode_buffer(bytes, len); asl_msg_set_key_val(aux, ASL_KEY_AUX_DATA, encoded); free(encoded); eval = _asl_evaluate_send(NULL, (aslmsg)aux, -1); _asl_send_message(NULL, eval, aux, NULL); asl_msg_release(aux); dispatch_release(md); &#125; &#125; if (done) &#123; //semaphore +1使得不需要再等待继续执行下去。 dispatch_semaphore_signal(sem); dispatch_release(pipe_channel); dispatch_release(pipe_q); &#125;&#125;); Dispatch Source 用GCD监视进程Dispatch Source用于监听系统的底层对象，比如文件描述符，Mach端口，信号量等。主要处理的事件如下表 方法 说明 DISPATCH_SOURCE_TYPE_DATA_ADD 数据增加 DISPATCH_SOURCE_TYPE_DATA_OR 数据OR DISPATCH_SOURCE_TYPE_MACH_SEND Mach端口发送 DISPATCH_SOURCE_TYPE_MACH_RECV Mach端口接收 DISPATCH_SOURCE_TYPE_MEMORYPRESSURE 内存情况 DISPATCH_SOURCE_TYPE_PROC 进程事件 DISPATCH_SOURCE_TYPE_READ 读数据 DISPATCH_SOURCE_TYPE_SIGNAL 信号 DISPATCH_SOURCE_TYPE_TIMER 定时器 DISPATCH_SOURCE_TYPE_VNODE 文件系统变化 DISPATCH_SOURCE_TYPE_WRITE 文件写入 方法 dispatch_source_create：创建dispatch source，创建后会处于挂起状态进行事件接收，需要设置事件处理handler进行事件处理。 dispatch_source_set_event_handler：设置事件处理handler dispatch_source_set_cancel_handler：事件取消handler，就是在dispatch source释放前做些清理的事。 dispatch_source_cancel：关闭dispatch source，设置的事件处理handler不会被执行，已经执行的事件handler不会取消。 1234567891011NSRunningApplication *mail = [NSRunningApplication runningApplicationsWithBundleIdentifier:@&quot;com.apple.mail&quot;];if (mail == nil) &#123; return;&#125;pid_t const pid = mail.processIdentifier;self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(self.source, ^()&#123; NSLog(@&quot;Mail quit.&quot;);&#125;);//在事件源传到你的事件处理前需要调用dispatch_resume()这个方法dispatch_resume(self.source); 监视文件夹内文件变化12345678910111213141516171819202122232425NSURL *directoryURL; // assume this is set to a directoryint const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);if (fd &lt; 0) &#123; char buffer[80]; strerror_r(errno, buffer, sizeof(buffer)); NSLog(@&quot;Unable to open \\&quot;%@\\&quot;: %s (%d)&quot;, [directoryURL path], buffer, errno); return;&#125;dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(source, ^()&#123; unsigned long const data = dispatch_source_get_data(source); if (data &amp; DISPATCH_VNODE_WRITE) &#123; NSLog(@&quot;The directory changed.&quot;); &#125; if (data &amp; DISPATCH_VNODE_DELETE) &#123; NSLog(@&quot;The directory has been deleted.&quot;); &#125;&#125;);dispatch_source_set_cancel_handler(source, ^()&#123; close(fd);&#125;);self.source = source;dispatch_resume(self.source);//还要注意需要用DISPATCH_VNODE_DELETE 去检查监视的文件或文件夹是否被删除，如果删除了就停止监听 NSTimer在主线程的runloop里会在runloop切换其它模式时停止，这时就需要手动在子线程开启一个模式为NSRunLoopCommonModes的runloop，如果不想开启一个新的runloop可以用不跟runloop关联的dispatch source timer，如下。12345678dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,0, 0, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(source, ^()&#123; NSLog(@&quot;Time flies.&quot;);&#125;);dispatch_time_t startdispatch_source_set_timer(source, DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC,100ull * NSEC_PER_MSEC);self.source = source;dispatch_resume(self.source); Dispatch Semaphore和的介绍另外一种保证同步的方法。使用dispatch_semaphore_signal加1dispatch_semaphore_wait减1，为0时等待的设置方式来达到线程同步的目的和同步锁一样能够解决资源抢占的问题。12345678910111213//dispatch semaphore- (void)dispatchSemaphoreDemo &#123; //创建semaphore dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;start&quot;); [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;semaphore +1&quot;); dispatch_semaphore_signal(semaphore); //+1 semaphore &#125;); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;continue&quot;);&#125; 锁这里简单介绍下iOS中常用的各种锁和他们的性能。 NSRecursiveLock：递归锁，可以在一个线程中反复获取锁不会造成死锁，这个过程会记录获取锁和释放锁的次数来达到何时释放的作用。 NSDistributedLock：分布锁，基于文件方式的锁机制，可以跨进程访问。 NSConditionLock：条件锁，用户定义条件，确保一个线程可以获取满足一定条件的锁。因为线程间竞争会涉及到条件锁检测，系统调用上下切换频繁导致耗时是几个锁里最长的。 OSSpinLock：自旋锁，不进入内核，减少上下文切换，性能最高，但抢占多时会占用较多cpu，好点多，这时使用pthread_mutex较好。 pthread_mutex_t：同步锁基于C语言，底层api性能高，使用方法和其它的类似。 @synchronized：更加简单。 dispatch_suspend和dispatch_resume挂起和恢复队列dispatch_suspend这里挂起不会暂停正在执行的block，只是能够暂停还没执行的block。 dispatch_set_context和dispatch_get_contextGCD深入操作 缓冲区：dispatch_data_t基于零碎的内存区域，使用dispatch_data_apply来遍历，还可以用dispatch_data_create_subrange来创建一个不做任何拷贝的子区域 I/O调度：使用GCD提供的dispatch_io_read，dispatch_io_write和dispatch_io_close 测试：使用dispatch_benchmark小工具 原子操作： libkern/OSAtomic.h里可以查看那些函数，用于底层多线程编程。 GCD死锁当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (void)deadLockCase1 &#123; NSLog(@&quot;1&quot;); //主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。 dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;2&quot;); &#125;); NSLog(@&quot;3&quot;);&#125;- (void)deadLockCase2 &#123; NSLog(@&quot;1&quot;); //3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行 dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@&quot;2&quot;); &#125;); NSLog(@&quot;3&quot;);&#125;- (void)deadLockCase3 &#123; dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL); NSLog(@&quot;1&quot;); dispatch_async(serialQueue, ^&#123; NSLog(@&quot;2&quot;); //串行队列里面同步一个串行队列就会死锁 dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;3&quot;); &#125;); NSLog(@&quot;4&quot;); &#125;); NSLog(@&quot;5&quot;);&#125;- (void)deadLockCase4 &#123; NSLog(@&quot;1&quot;); dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;2&quot;); //将同步的串行队列放到另外一个线程就能够解决 dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;3&quot;); &#125;); NSLog(@&quot;4&quot;); &#125;); NSLog(@&quot;5&quot;);&#125;- (void)deadLockCase5 &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;1&quot;); //回到主线程发现死循环后面就没法执行了 dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;2&quot;); &#125;); NSLog(@&quot;3&quot;); &#125;); NSLog(@&quot;4&quot;); //死循环 while (1) &#123; // &#125;&#125; GCD实际使用FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁作用类似objc_setAssociatedObject跟objc_getAssociatedObject1234567891011static const void * const kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;//创建串行队列，所有数据库的操作都在这个队列里_queue = dispatch_queue_create([[NSString stringWithFormat:@&quot;fmdb.%@&quot;, self] UTF8String], NULL);//标记队列dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);//检查是否是同一个队列来避免死锁的方法- (void)inDatabase:(void (^)(FMDatabase *db))block &#123; FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey); assert(currentSyncQueue != self &amp;&amp; &quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;);&#125; iOS系统版本新特性iOS8iOS8新加了一个功能叫Quality of Service(QoS)，里面提供了一下几个更容易理解的枚举名来使用user interactive，user initiated，utility和background。下面的表做了对比 Global queue Corresponding QoS class 说明 Main thread NSQualityOfServiceUserInteractive UI相关，交互等 DISPATCH_QUEUE_PRIORITY_HIGH NSQualityOfServiceUserInitiated 用户发起需要马上得到结果进行后续任务 DISPATCH_QUEUE_PRIORITY_DEFAULT NSQualityOfServiceDefault 默认的不应该使用这个设置任务 DISPATCH_QUEUE_PRIORITY_LOW NSQualityOfServiceUtility 花费时间稍多比如下载，需要几秒或几分钟的 DISPATCH_QUEUE_PRIORITY_BACKGROUND NSQualityOfServiceBackground 不可见在后台的操作可能需要好几分钟甚至几小时的 参考资料WWDC Building Responsive and Efficient Apps with GCD：https://developer.apple.com/videos/play/wwdc2015-718/ 文档 官方文档：https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/","categories":[],"tags":[{"name":"转载","slug":"转载","permalink":"http://www.zhimakaiyuan.com/tags/转载/"},{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"},{"name":"笔记","slug":"笔记","permalink":"http://www.zhimakaiyuan.com/tags/笔记/"}]},{"title":"用Let's encrypt 免费给自己的博客加上https之小白版","slug":"https-for-lets-encrypt","date":"2016-12-17T05:47:56.000Z","updated":"2016-12-17T05:50:33.000Z","comments":true,"path":"2016/12/17/https-for-lets-encrypt/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/12/17/https-for-lets-encrypt/","excerpt":"最近公司任务不是很重，适配iOS 10 ATS 已经成为了项目这一个月的任务，杨老大负责任的把这个重担一个人扛下了，因此我等小民就只能自己去研究了，于是就寻思着给自己的博客加上ssl验证，有个小绿锁🔒 看起来确实是舒坦很多。在这里就记录下全过程。","text":"最近公司任务不是很重，适配iOS 10 ATS 已经成为了项目这一个月的任务，杨老大负责任的把这个重担一个人扛下了，因此我等小民就只能自己去研究了，于是就寻思着给自己的博客加上ssl验证，有个小绿锁🔒 看起来确实是舒坦很多。在这里就记录下全过程。 前言HTTPS目前已经成为各大主流网站的标配，未来必将成为一种趋势，很多个人博客现在也都加入了HTTPS的阵营。HTTPS好处多多，可以防止各种攻击劫持，运营商广告植入，客户传输信息泄露等问题。为了让HTTPS能够全面普及，Let’s Encrypt项目应运而生，它由互联网安全研究小组ISRG（Internet Security Research Group）提供服务，ISRG是来自美国加利福尼亚州的一个公益组织。Let’s Encrypt 得到了 Mozilla、Cisco和 Chrome 等众多公司和机构的支持。 关于Let’s EncryotLet’s Encrypt 是一个新的 CA，他能够提供一种非常容易的方式来获取和安装免费的 TLS/SSL 证书，从而在 web 服务器上启用 HTTPS 加密。他通过提供软件客户端 letsencrypt 来简化这个过程，它企图自动完成大部分所需的必要步骤。当前，Let’s Encrypt 仍然处在公开测试阶段，他整个获取和安装证书的流程只在 Apache 服务器上实现了全部自动化。然而 Let’s Encrypt 也可以很容易的在其他不同的服务器上获取和安装免费的 SSL 证书。 申请 Let’s Encrypt 证书不仅免费、代码开源，而且配置简单，不过每次申请只有90天的有效期，但可以通过脚本定期更新，配置好之后一劳永逸。 下面就开始来一起看看吧～ 第一步：创建 LET’S ENCRYPT 账号（如何你没有的话),并生成CSR文件为了区分其他，我们现创建一个文件夹，用来单独存放账号、证书和key 12mkdir sslcd ssl Let’s Encrypt使用一个私钥来进行账号的创建与登陆，因此我们需要使用openssl创建一个account.key。首先我们需要看下我们的openssl的安装目录，并记录下openssl.cnf 文件的地址。 1openssl version –a 从这里我们可以看到当出openssl的安装路径 123456OpenSSL 1.0.2g 1 Mar 2016built on: reproducible build, date unspecifiedplatform: debian-amd64options: bn(64,64) rc4(16x,int) des(idx,cisc,16,int) blowfish(idx) compiler: cc -I. -I.. -I../include -fPIC -DOPENSSL_PIC -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -m64 -DL_ENDIAN -g -O2 -fdebug-prefix-map=/build/openssl-wIGtVG/openssl-1.0.2g=. -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2 -Wl,-Bsymbolic-functions -Wl,-z,relro -Wa,--noexecstack -Wall -DMD32_REG_T=int -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM -DECP_NISTZ256_ASMOPENSSLDIR: \"/usr/lib/ssl\" //这个就是我们需要的openssl的路径了 这一步完成后，我们开始我们的第一步 创建Let’s Encrypt私钥首先进入我们刚刚的ssl 文件夹，然后生成私钥12cd sslopenssl genrsa 4096 &gt; account.key 创建CSR(Certificate Signing Request，证书签名请求) 文件 ACME协议 (Let’s Encrypt所使用的) 需要一个csr文件，用来进行证书签名和证书更新。 将需要加密的域名加到下面的代码中，目前一张证书最多可以加密 100 个域名，注意命令行中的域名换成你自己的域名： 123openssl genrsa 4096 &gt; domain.keyopenssl req -new -sha256 -key domain.key -subj \"/\" -reqexts SAN -config &lt;(cat /usr/lib/ssl/openssl.cnf &lt;(printf \"[SAN]\\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com\")) &gt; domain.csr 注意：openssl.cnf 文件的位置可能会因为linux版本的不同而有变，我们只需要在上一步中的openssl 路径后面加上/openssl.cnf 现在我们已经生成了csr和私钥，接下来就到了比较纠结的一步了，需要证明你拥有该域名 配置域名验证CA 在签发 DV（Domain Validation）证书时，需要验证域名所有权。传统 CA 的验证方式一般是往 admin@youmail.com 发验证邮件，而 Let’s Encrypt 是在你的服务器上生成一个随机验证文件，再通过创建 CSR 时指定的域名访问，如果可以访问则表明你对这个域名有控制权。 首先创建用于存放验证文件的目录，然后通过 “.well-known/acme-challenge/“ 这个URL来访问到验证文件. 注意: Let’s Encrypt 会对你的服务器做一次http请求来进行验证，因此你需要保证80端口能够访问： 1mkdir -p /var/www/challenges 然后配置一个 HTTP 服务，以 Nginx 为例：(注意：这里的端口是80，不是443） 1234567891011121314151617//这个是新增加的一个servrserver &#123;listen 80;server_name yoursite.com www.yoursite.com;if ( $request_uri !~ \"/.well-known/acme-challenge/*\" ) &#123; # 让 Let's Encrypt 成功访问到验证文件不受 301 影响return 301 https://yoursite.com$request_uri; # 注意进行301重定向到https，否则通过http仍能访问你的站点&#125;location /.well-known/acme-challenge/ &#123;alias /var/www/challenges/;try_files $uri =404;&#125;#...你的其他配置&#125; 这个验证服务以后更新证书还要用到，需要一直保留。 获取网站证书先回到我们的ssl目录，然后把 acme-tiny 脚本保存到 ssl 目录 12345cdcd sslwget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.pysudo chmod +x acme_tiny.py python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /var/www/challenges/ &gt; ./signed.crt 如果一切正常，当前目录下就会生成一个 signed.crt，这就是申请好的证书文件。 安装证书证书生成后，就可以把它配置在web 服务器上了，需要注意的是，Nginx需要追加一个Let’s Encrypt的中间证书，在 Nginx 配置中，需要把中间证书和网站证书合在一起：``wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pemcat signed.crt intermediate.pem &gt; chained.pem 123最终，修改 Nginx 中有关证书的配置并 reload 服务即可：## 修改 Nginx 中有关证书的配置并 reload 服务 server {listen 443;server_name yoursite.com, www.yoursite.com; ssl on;ssl_certificate /path/to/chained.pem;ssl_certificate_key /path/to/domain.key;ssl_session_timeout 5m;ssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA;ssl_session_cache shared:SSL:50m;ssl_prefer_server_ciphers on; #…你的其他配置} server { listen 80;server_name yoursite.com www.yoursite.com; if ( $request_uri !~ “/.well-known/acme-challenge/*” ) { # 让 Let’s Encrypt 成功访问到验证文件不受 301 影响return 301 https://yoursite.com$request_uri; # 注意进行301重定向到https，否则通过http仍能访问你的站点} location /.well-known/acme-challenge/ {alias /var/www/challenges/;try_files $uri =404;} #…你的其他配置} 大功告成好了，现在就能重启你的nginx1nginx -s reload 后续恭喜！你的网站已经使用上了HTTPS。 但Let’s Encrypt 证书有效期只有90天, 所以需要定期更新。现在只需要写一个更新脚本并把它放到定时任务中即可。 在ssl的文件夹内进行如下操作1234cdcd ssltouch renew_cert.shvi renew_cert.sh 然后在renew_cert.sh中输入12345#!/usr/bin/shpython /root/ssl/acme_tiny.py --account-key /root/ssl/account.key --csr /root/ssl/domain.csr --acme-dir /var/www/challenges/ &gt; /tmp/signed.crt || exitwget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pemcat /tmp/signed.crt intermediate.pem &gt; /root/ssl/chained.pemservice nginx reload 定时任务可以设置为每个月执行一次：10 0 1 * * /root/ssl/acme-tiny/renew_cert.sh 2&gt;&gt; /var/log/acme_tine.log 以上就是整个的全过程了。欢迎享受HTTPS之旅～","categories":[],"tags":[{"name":"https","slug":"https","permalink":"http://www.zhimakaiyuan.com/tags/https/"},{"name":"瞎折腾","slug":"瞎折腾","permalink":"http://www.zhimakaiyuan.com/tags/瞎折腾/"}]},{"title":"Xcode8在Objective-C中集成Charts 3.0（全是坑！！！）","slug":"Xcode8-Uses-Charts-Objective-C","date":"2016-12-06T09:04:26.000Z","updated":"2016-12-16T08:08:21.000Z","comments":true,"path":"2016/12/06/Xcode8-Uses-Charts-Objective-C/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/12/06/Xcode8-Uses-Charts-Objective-C/","excerpt":"用cocoapods集成Charts说多了都是泪，全是坑！不过全都搞好以后，画图表还是很方便的。","text":"用cocoapods集成Charts说多了都是泪，全是坑！不过全都搞好以后，画图表还是很方便的。 不知咋滴，一大早起来后把项目clean了一下，然后把pod文件全删了，重新运行1pod install 然后再clean，居然好了。。。下面记录下踩坑的整个过程 Charts 是何方神圣Charts是一套非常漂亮的开源图表组件，它是MPAndroidChart在苹果端的移植版本，同时支持iOS/tvOS/OSX平台，开源地址Github。 同时，Charts是用 Swift 语言编写的，能够在 Swift 和 Objc 工程中使用。 使用环境 Xcode 8.0 / Swift 3.0 (如果要支持 Swift 2.3 ，请查看 Charts 2.3) iOS &gt;= 8.0 tvOS &gt;= 9.0 macOS &gt;= 10.11 使用方法本文使用的是通过cocopods 来安装的，中间的过程有点曲折 通过 cocoapods 集成如果项目还未使用cocoapods，可用终端在根目录下输入1pod init 然后在项目的 Podfile 文件中添加 Charts1pod 'Charts', '~&gt; 3.0' 如果不出意外的话，会在安装过程中报个小错 1[!] Pods written in Swift can only be integrated as frameworks; add `use_frameworks!` to your Podfile or target to opt into using it. The Swift Pod being used is: Charts 恭喜踩到了第一个坑 为什么呢原来根据苹果的相关政策，在 Swift项目中苹果将不允许你私自包含静态库了，因此我们的解决办法是,在 podfile 文件中 添加这么一句12pod 'Charts', '~&gt; 3.0'use_frameworks! use_frameworks！选项是告诉 CocoaPods 使用 framework 而不是静态库。这在 Swift 项目中是必选。 完成之后，我们开始导入 导入库在项目的根目录下，输入1pod install 静待几分钟后，会有提示倒入成功这时候，我们需要打开 xcworkspace 文件,注意哦，是 xcworkspace 不再是原来的 xcodeproj文件了 因为我们的项目是 OC 的，而 Charts 是用 Swift 编写的，所以需要创建一个桥接文件完成后，会有提示是否需要桥接，点击 Create Bridging Header 执行完这一步后，如果有报错之类的，可以先把项目 clean 一下 敲黑板 这是一道送分题，千万不能忘 接着在桥接文件 项目名-Bridging-Header.h 中，写上要引用的 Swift 头文件。1@import Charts; 大功告成进入测试阶段在ViewController.m中加入如下代码：12345678910111213141516171819202122232425262728293031323334353637383940- (void)viewDidLoad &#123;[super viewDidLoad];self.view.backgroundColor = [UIColor colorWithRed:0.184 green:1.000 blue:0.738 alpha:1.000];lineView = [[LineChartView alloc]initWithFrame:CGRectMake(0, self.view.bounds.size.height / 3.0f,[UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height / 3.0)];lineView.backgroundColor = [UIColor colorWithRed:0.184 green:1.000 blue:0.738 alpha:1.000];[self.view addSubview:lineView];lineView.dragEnabled = YES;//是否拖拽，lineView.drawGridBackgroundEnabled = NO;//绘制网格背景lineView.scaleXEnabled = NO;lineView.pinchZoomEnabled = NO;lineView.descriptionText = @\"每月收入支出图\";//X轴设置ChartXAxis *xAxis = lineView.xAxis;xAxis.labelPosition = XAxisLabelPositionBothSided;//X轴样式xAxis.drawLabelsEnabled = YES;//X轴是否需要绘制文字xAxis.drawAxisLineEnabled = YES;//X轴绘制xAxis.drawGridLinesEnabled = NO;//X轴网格绘制xAxis.axisLineWidth = 0.4f;//数轴宽度[xAxis setLabelCount:10 force:NO];//X轴数量一般默认是6个//Y轴设置ChartYAxis *yAxis = lineView.leftAxis;yAxis.spaceTop = .5f;//Y轴顶部的最大值的百分比yAxis.labelFont = [UIFont fontWithName:@\"HelveticaNeue-Light\" size:12.f];[yAxis setLabelCount:5 force:NO];//Y轴坐标个数yAxis.labelTextColor = [UIColor blackColor];//Y轴坐标文字颜色yAxis.labelPosition = YAxisLabelPositionInsideChart;yAxis.drawGridLinesEnabled = NO;//Y轴网格yAxis.axisLineColor = UIColor.blackColor;lineView.rightAxis.enabled = NO;int count = 30;double range = 10;[self setDataCount:count range:range];[lineView animateWithXAxisDuration:3 yAxisDuration:3];// Do any additional setup after loading the view, typically from a nib.&#125; 然后随机配置一下数据，就能看到两条曲线了完美🤗demo地址：ChartsDemo 参考博客Cocoapods 安装参考Swift静态库参考","categories":[{"name":"吐槽","slug":"吐槽","permalink":"http://www.zhimakaiyuan.com/categories/吐槽/"},{"name":"技术","slug":"吐槽/技术","permalink":"http://www.zhimakaiyuan.com/categories/吐槽/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"}]},{"title":"Add SSH Key to Your Remote Client","slug":"add-SSH-Key-to-Your-remote-clint","date":"2016-11-03T05:26:30.000Z","updated":"2016-12-14T02:41:29.000Z","comments":true,"path":"2016/11/03/add-SSH-Key-to-Your-remote-clint/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/11/03/add-SSH-Key-to-Your-remote-clint/","excerpt":"前段时间，买了Vultr家的VPS用作shadowsocks，最近突然很感兴趣，于是捣鼓了下，每次登录的时候都需要输入密码有点麻烦，就找到了如何用ssh登录的方法。","text":"前段时间，买了Vultr家的VPS用作shadowsocks，最近突然很感兴趣，于是捣鼓了下，每次登录的时候都需要输入密码有点麻烦，就找到了如何用ssh登录的方法。 准备工作Mac、VPS（安装的是ubuntu 16.0） 工作原理ssh除了使用密码验证外，还提供了一种公私密钥的验证方式。客户端生成一个私钥，并生成一个与之对应的公钥，然后将公钥上传到服务器上。 开始准备 在本地机器创建公钥在客户端生成私钥、公钥（注意，在Mac 上完成）1ssh-keygen -t rsa -C 'your email' 然后一路回车，生成你自己的密钥对，成功截图如下 将公钥复制到ssh服务器将前一步骤生成的公钥~/id_rsa.pub文件，复制到ssh服务器对应用户下的~/.ssh/authorized_keys文件,可以有多种方式，这里只介绍常用的一种。12brew install ssh-copy-idssh-copy-id username@hostname #将username和hostname替换为你的ssh服务器用户名和IP 当ssh服务器username用户目录下尚未有.ssh目录时使用此方式1cat ~/.ssh/id_rsa.pub | ssh username@hostname \"mkdir ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys\" 通用方式1234scp ~/.ssh/id_rsa.pub username@hostname:~/ #将公钥文件复制至ssh服务器ssh username@hostname #使用用户名和密码方式登录至ssh服务器mkdir .ssh #若.ssh目录已存在，可省略此步cat id_rsa.pub &gt;&gt; .ssh/authorized_keys #将公钥文件id_rsa.pub文件内容追加到authorized_keys文件 快捷登录完成以上步骤后，即可使用以下命令直接登录ssh服务器，妈妈再也不用担心你记不住密码了以后登录ssh，只需要在你的Mac上输入 username@hostname``` 即可不用输入密码啦～123456789# 思考即使这样，我们还是需要输入远程服务器的ip地址，有时候真的脑容量不够啊，怎么办，怎么办，怎么办！！！没关系，我们还能实现本地一条命令就能登录**ssh本身也提供了一种快捷的方式来解决这个问题，往~/.ssh/config配置文件添加你的ssh服务器信息即可**在本地可客户端（你的Mac）输入 vim ~/.ssh/config1然后在终端输入 i 开始插入如下内容： Host name#自定义别名HostName hostname #替换为你的ssh服务器ip或domainPort 22 #ssh服务器端口，默认为22User root #ssh服务器用户名IdentityFile ~/.ssh/id_rsa #第一个步骤生成的公钥文件对应的私钥文件1234按下ESC，然后依次输入 :wq保存并退出最终，我们只需要在终端输入 ssh name```就能远程登录我们的VPS啦～ 写在最后这篇文章多亏了我们的黄小贱同学","categories":[{"name":"技术","slug":"技术","permalink":"http://www.zhimakaiyuan.com/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://www.zhimakaiyuan.com/tags/工具/"},{"name":"VPS","slug":"VPS","permalink":"http://www.zhimakaiyuan.com/tags/VPS/"}]},{"title":"Mac上搭建shadowsocks服务","slug":"Mac上搭建shadowsocks服务","date":"2016-10-27T06:27:24.000Z","updated":"2016-12-14T02:42:17.000Z","comments":true,"path":"2016/10/27/Mac上搭建shadowsocks服务/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/10/27/Mac上搭建shadowsocks服务/","excerpt":"之前看着教程自己也乱七八糟的搭建了一个ss的服务端，但是感觉一团糟，于是趁着自己有时间，就重新搭建一下，顺便好好记录下搭建的过程，方便自己，也希望能给其他刚接触的一点帮助。首先我自己的是一台Mac，所以主要记录的也是Mac上的操作，我的vps买的是搬瓦工19.99$的，目前使用感觉还行。","text":"之前看着教程自己也乱七八糟的搭建了一个ss的服务端，但是感觉一团糟，于是趁着自己有时间，就重新搭建一下，顺便好好记录下搭建的过程，方便自己，也希望能给其他刚接触的一点帮助。首先我自己的是一台Mac，所以主要记录的也是Mac上的操作，我的vps买的是搬瓦工19.99$的，目前使用感觉还行。 写在最前面：为什么翻墙？应该每个人都有自己的原因，总的来说，还是”赵家人“管得太宽，各种访问不了目前使用的工具也是种类繁多，很多免费的不稳定，速度慢，使用起来也不见得安全，付费的虽然好点，但是依然是使用的别人的代理服务器。因此，还是我们自己来搭一个吧，至于为什么选择ss，主要是觉得搭建比较方便，而且安全性想对较好 需要准备哪些电脑（Mac）、vps（ubuntu 16 ＊ 64） shadowsocks 服务器安装登陆你的远程服务器打开Mac自带的终端ssh root@你的ip -p 你的ssh端口，若没有特殊分配，一般都是22 更新源软件1root@localhost:~# sudo apt-get update 更新完成后，会有提示 安装PIP环境root@localhost:~# sudo apt-get install python-pip由于原作者已经不再更新 pip 下的源代码，故不再使用 pip 安装 Shadowsocks。 安装shadowsocks pip install shadowsocks 由于原作者已经不再更新 pip 下的源代码，故不再使用 pip 安装 Shadowsocks，而是改为下载 Github 的 master 分支来安装。如果在一段时间后，版本升级了，则先卸载，并再次执行本脚本就可以升级为最新版。这里采用了秋水逸冰的博客，采用该一键安装 Python 版 Shadowsocks 的最新版，同时安装了 Python 包管理工具 pip。 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 安装完成后，脚本提示如下12345678910Congratulations, shadowsocks install completed!Your Server IP:your_server_ipYour Server Port:your_server_portYour Password:your_passwordYour Local IP:127.0.0.1Your Local Port:1080Your Encryption Method:aes-256-cfbWelcome to visit:https://teddysun.com/342.htmlEnjoy it! 卸载方法1./shadowsocks.sh uninstall 进入配置1vi /etc/shadowsocks.json 键盘上按下「i」键，进入Insert mode 单用户配置文件12345678910&#123;\"server\":\"0.0.0.0\",\"server_port\":8989,\"local_address\":\"127.0.0.1\",\"local_port\":1080,\"password\":\"yourpassword\",\"timeout\":300,\"method\":\"aes-256-cfb\",\"fast_open\": false&#125; 多用户配置文件123456789101112131415&#123;\"server\":\"0.0.0.0\",\"local_address\":\"127.0.0.1\",\"local_port\":1080,\"port_password\":&#123;\"8989\":\"password0\",\"9001\":\"password1\",\"9002\":\"password2\",\"9003\":\"password3\",\"9004\":\"password4\"&#125;,\"timeout\":300,\"method\":\"aes-256-cfb\",\"fast_open\": false&#125; 这里需要注意,””{}不要漏了配置完成之后，先按「esc」退出，然后按一下「：」冒号键进入「Last line mode」，例如： : w filename （输入 「w filename」将文章以指定的文件名filename保存） : wq (输入「wq」，存盘并退出vi) : q! (输入q!， 不存盘强制退出vi)这里我们直接存盘并退出，「：wq」 使用命令1234启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status 参考链接http://jiji262.github.io/2016/09/28/setup-Shadowsocks-on-ubuntu-1604/https://teddysun.com/342.html","categories":[{"name":"技术","slug":"技术","permalink":"http://www.zhimakaiyuan.com/categories/技术/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://www.zhimakaiyuan.com/tags/工具/"},{"name":"翻墙","slug":"翻墙","permalink":"http://www.zhimakaiyuan.com/tags/翻墙/"},{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://www.zhimakaiyuan.com/tags/Shadowsocks/"}]},{"title":"Effective-Objective-C 2.0笔记","slug":"Effective-Objective-C-2-0笔记","date":"2016-10-10T02:51:38.000Z","updated":"2016-12-14T02:41:47.000Z","comments":true,"path":"2016/10/10/Effective-Objective-C-2-0笔记/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/10/10/Effective-Objective-C-2-0笔记/","excerpt":"上一个博客写了Effective Objective-C 2.0 的总的概览，这一章准备记录一下本书中提到的编写高质量iOS 与 OS X 代码的52个有效方法","text":"上一个博客写了Effective Objective-C 2.0 的总的概览，这一章准备记录一下本书中提到的编写高质量iOS 与 OS X 代码的52个有效方法 第1条:了解 Objective-C 语言的起源第2条:在类的头文件中尽量少引入其他文件第3条:多用字面量语法，少用与之等价的方法第4条:多用类型常量，少用 #define 预处理指令第5条:用枚举表示状态、选项、状态码 第6条:理解“属性”这一概念第7条:在对象内部尽量直接访问实例变量第8条:理解“对象等同性”这一概念第9条:以“类族模式”隐藏实现细节第10条:在既有类中使用关联对象存放自定义数据第11条:理解 obje_msgSend 的作用第12条:理解消息转发机制第13条:用“方法调配技术”测试“黑盒方法”第14条:理解“类对象”的用意 第15条:用前缀避免命名空间冲突第16条:提供“全能初始化方法”第17条:实现 description 方法第18条:尽量使用不可变对象第19条:使用清晰而协调的命名方式第20条:为私有方法名加前缀第21条:理解 Objective-C 错误模型第22条:理解 NSCopying 第23条:通过委托与数据源协议进行对象间通信第24条:将类的实现代码分散到便于管理的数个分类之中第25条:总是为第三方类的分类名称加前缀第26条:勿在分类中声明属性第27条:使用 “class-continuation 分类”隐藏实现细节第28条:通过协议提供匿名对象 第29条:理解引用计数第30条:以 ARC 简化引用计数第31条:","categories":[{"name":"学习","slug":"学习","permalink":"http://www.zhimakaiyuan.com/categories/学习/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"},{"name":"笔记","slug":"笔记","permalink":"http://www.zhimakaiyuan.com/tags/笔记/"}]},{"title":"Effective-Objective-C 2.0笔记（概览）","slug":"Effective-Objective-C-2-0笔记（概览）","date":"2016-02-01T07:19:23.000Z","updated":"2016-12-14T02:41:57.000Z","comments":true,"path":"2016/02/01/Effective-Objective-C-2-0笔记（概览）/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/02/01/Effective-Objective-C-2-0笔记（概览）/","excerpt":"一直想说要读完这本书，结果在咸鱼老湿的督促下，还是没能看完，努力还是要靠自己啊，今天正好有时间，就先把标题里在这里。我们先定个小目标，比方说，先把这52个有效方法写出来，以后再慢慢填充。编写高质量iOS与OS X代码的52个有效方法。","text":"一直想说要读完这本书，结果在咸鱼老湿的督促下，还是没能看完，努力还是要靠自己啊，今天正好有时间，就先把标题里在这里。我们先定个小目标，比方说，先把这52个有效方法写出来，以后再慢慢填充。编写高质量iOS与OS X代码的52个有效方法。本书分为七章，分别是 熟悉 Objective-C通论该语言的核心概念 对象、消息、运行期对象之间能够关联与交互，这是面向对象语言的重要特征。贲张讲述这些特性，并深入研究代码在运行期的行为。 接口与 API 设计很少有那种写完就不再复用的代码。即使代码不向更多人公开，也依然有可能用在自己的多个项目中。本章讲解如何编写与 Objective-C 搭配得宜的类。 协议与分类协议与分类是两个需要掌握的重要语言特性。若运用得当，则可以令代码易读、易维护且少出错。本章将帮助读者精通这两个概念。 内存管理Objective-C 语言以引用计数来管理内存，这令许多初学者纠结，要是用过以“垃圾收集器” (garbage collector)来管理内存的语言，那么更会如此。“自动引用计数”机制缓解了此问题，不过使用时有很多重要的注意事项，以确保对象模型正确，不致内存泄漏。本章提醒读者注意内存管理中易犯的错误。 块与大中枢派发苹果公司引入了“块”这一概念，其余法类似于 C 语言扩展中的“闭包”(closure)。在 Objective-C 语言中，我们通常采用块来实现一些原来需要很多样板代码才能完成的事情，块还能实现“代码分离”(code separation)。“大中枢派发”(Grand Central Dispatch,GCD) 提供了一套用于多线程环境的简单接口。“块”可视为GCD的任务，根据系统资源状况，这些任务也许能并发执行。本章将教会读者如何充分运用这两项核心技术。 系统框架大家通常会用 Objective-C 开开发Mac OS X 或 iOS 程序。在这两种情况下都有一套完整的系统框架可供使用，前者名为 Cocoa ，后者名为 Cocoa Touch。本章将总览这些框架，并深入研究其中某些类。 共有52个有效方法，会在下一章博客中写出来","categories":[{"name":"学习","slug":"学习","permalink":"http://www.zhimakaiyuan.com/categories/学习/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"},{"name":"笔记","slug":"笔记","permalink":"http://www.zhimakaiyuan.com/tags/笔记/"}]},{"title":"开始健身","slug":"开始健身","date":"2016-01-15T04:03:40.000Z","updated":"2016-12-14T02:47:24.000Z","comments":true,"path":"2016/01/15/开始健身/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/01/15/开始健身/","excerpt":"","text":"####终于开始健身了，今天将是第三次去了，还是矫正体型，看来健身的道路很漫长啊。距离目标身材还很遥远，加油吧，骚年！","categories":[{"name":"生活","slug":"生活","permalink":"http://www.zhimakaiyuan.com/categories/生活/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://www.zhimakaiyuan.com/tags/碎碎念/"},{"name":"健身","slug":"健身","permalink":"http://www.zhimakaiyuan.com/tags/健身/"}]},{"title":"CocoaPods的使用与安装","slug":"CocoaPods的使用与安装","date":"2016-01-12T05:07:11.000Z","updated":"2016-12-14T02:41:39.000Z","comments":true,"path":"2016/01/12/CocoaPods的使用与安装/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/01/12/CocoaPods的使用与安装/","excerpt":"什么是CocoaPodsCocoaPods是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具，而其本身是利用ruby的依赖管理gem进行构建的。因此，在解析整合过程中，最重要的几个gems分别是：CocoaPods/CocoaPods, CocoaPods/Core, 和 CocoaPods/Xcodeproj。在我们的工程里面会用到JSONKit、AFNetWorking等第三方开源库，首次在工程中引入这些第三方库的时候，会涉及许多配置，尤其是在build phases和linker flags配置中过程中，会引起许多人为因素的错误。CocoaPods的出现简化了这一切，并且可以通过CocoaPods查找新的第三方库。","text":"什么是CocoaPodsCocoaPods是开发 OS X 和 iOS 应用程序的一个第三方库的依赖管理工具，而其本身是利用ruby的依赖管理gem进行构建的。因此，在解析整合过程中，最重要的几个gems分别是：CocoaPods/CocoaPods, CocoaPods/Core, 和 CocoaPods/Xcodeproj。在我们的工程里面会用到JSONKit、AFNetWorking等第三方开源库，首次在工程中引入这些第三方库的时候，会涉及许多配置，尤其是在build phases和linker flags配置中过程中，会引起许多人为因素的错误。CocoaPods的出现简化了这一切，并且可以通过CocoaPods查找新的第三方库。 CocoaPods的工作原理CocoaPods的原理是将所有的依赖库都放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个 .a文件即可。 CocoaPods的安装上面已经提到了，CocoaPods是利用Ruby的依赖管理gem进行构建，因此安装CocoaPods需要在ruby的环境下。 1.Ruby环境搭建Mac OS是自带ruby环境的，但是保险起见，还是需要更新一下。a.查看当前ruby版本打开Mac的terminal 输入ruby -v代码如下12$ ruby -vruby 2.0.0p645 (2015-04-13 revision 50299) [universal.x86_64-darwin15](#) b.更换ruby源终端输入如下命令（ruby的软件源rubygems.org因为使用的亚马逊的云服务，所以被墙了，需要更新一下ruby的源，国内常用的镜像服务有淘宝阿里云的，山东理工大学的,一般使用淘宝的）gem sources –remove https://rubygems.org/gem sources -a https://ruby.taobao.org/gem sources -l （用来检查使用替换镜像位置成功）代码如下123456789$ gem sources --remove https://rubygems.org/https://rubygems.org/ removed from sources$ gem sources -a https://ruby.taobao.org/https://ruby.taobao.org/ added to sources$ gem sources -l*** CURRENT SOURCES ***http://rubygems-china.oss.aliyuncs.comhttps://ruby.taobao.org/ 2.升级gemsudo gem update –system升级成功后，代码如下 3.下载安装CocoaPods安装CocoaPods（OS X 10.11以前） sudo gem install cocoapods安装CocoaPods（10.11后苹果升级了安全策略） sudo gem install -n /usr/local/bin cocoapods安装更新后，会有 gem installed提示 所有的项目的Podspec文件都托管在https://github.com/CocoaPods/Specs。第一次执行pod setup时，CocoaPods会将这些podspec索引文件更新到本地的 /.cocoapods/目录下，这个索引文件比较大，有80M左右。所以第一次更新时非常慢，一般更新了将近1个小时才完成。一个叫akinliu的朋友在gitcafe和oschina上建立了CocoaPods索引库的镜像，因为gitcafe和oschina都是国内的服务器，所以在执行索引更新操作时，会快很多。如下操作可以将CocoaPods设置成使用gitcafe镜像：1.移除原有服务器 pod repo remove master2.添加境内服务器（建议使用第一个） pod repo add master https://gitcafe.com/akuandev/Specs.git pod repo add master http://git.oschina.net/akuandev/Specs.git(开源中国较慢)使用及截图如下 完成后，执行操作：1pod setup 执行结束后代码如下图：至此，CocoaPods就完全安装结束，so easy！ CocoaPods的使用1.新建Podfile文件使用时需要在你的项目根目录下新建一个名为Podfile的文件，将依赖的库名字依次列在文件中即可12promote: lhl$ cd /Users/chengmei/Desktop/Test promote:Test lhl$ touch Podfile 这时候，在你的工程文件中就新建了一个名为Podfile的文件。 2.编辑Podfile文件用文本编辑器打开刚才新建的Podfile文件，此时的文件应是空白的，Podfile 文件的格式应该类似以下：1234platform :ios, '7.0'pod 'AFNetworking'， '&gt; 3.0.4'pod 'LCTabBarController'， '&gt; 1.2.2'pod 'LCBannerView' 注意*a. platform 那一行，ios 三个字母都要小写，而且与前面的冒号之间不能有间隔。b. 后面的版本号也可以不写，但是有些开源库对版本是有要求的，比如要在 iOS 7.0 以上才能运行，遇到这样的开源库就需要写上版本号。c. platform 下面就是 CocoaPods 需要集成的开源库，根据你的需要确定集成成些库。 3.查找所需要的类库例如，我们需要在工程文件中添加AFNetworking，首先需要在 CocoaPods 里面先搜索是否有需要的库，在 Terminal 中输入：1pod search AFNetworking 所显示代码如下：1pod 'AFNetworking', '&gt; 3.0.4' 就是需要我们在Podfile文件里面写的,把它复制，粘贴进去，并保存。 4.执行导入命令12$ cd /Users/chengmei/Desktop/Test$ pod install 导入成功后，如下截图所示pod install命令执行成功后，会看到工程目录下多出CocoaPodsTest.xcworkspace、Podfile.lock文件和Pods目录。再看看刚才执行完pod install命令打印出来的内容的最后一行：1[!](#) Please close any current Xcode sessions and use `Test.xcworkspace` for this project from now on. 提示我们从现在起，我们需要使用CocoaPodsTest.xcworkspace文件来开发。 5.第三方库更新与添加当需要添加第三方库时，只需要直接在Podfile里面添加第三方库信息，在terminal里面导入执行命令：12$ cd /Users/chengmei/Desktop/Test$ pod update 即可添加并更新成功。至此，我们CocoaPods的安装与使用就全部结束，往后我们只需在.xcworkspace文件里面编写即可。 遇到过的坑 首先就是系统升级成10.11后，由于苹果加强了安全策略，原来的sudo gem install cocoapods命令不再起作用，在10.11以前的系统中任然适用。10.11后需要适用命令sudo gem install -n /usr/local/bin cocoapods 这个问题折腾我好久，最后发现是在ios, ‘7.0’这个逗号后面我多输入了一个空格。 31[!] Invalid Podfile file: undefined local variable or method 'en_US' for #&lt;Pod::Podfile:0x00000102a5d8b0&gt;. Updating CocoaPods might fix the issue. 此错误也是常见的，原因：单引号格式，可能是手动输入导致解决办法：前往 系统偏好设置 - 键盘 - 文本 - 将“使用智能引号和破折号”一项取消勾选 - 再将 Podfile 里面的单（双）引号修改一下。如果遇到了神奇的报错，执行下面的命令 123$ sudo gem update --system$ sudo gem install cocoapods$ pod setup 重装吧 更多1、pod install提速每次执行pod install和pod update的时候，cocoapods都会默认更新一次spec仓库。这是一个比较耗时的操作。在确认spec版本库不需要更新时，给这两个命令加一个参数跳过spec版本库更新,可以明显提高这两个命令的执行速度。12pod install --verbose --no-repo-updatepod update --verbose --no-repo-update 2、关于Podfile文件编辑时，第三方库版本号的各种写法123456789pod ‘AFNetworking’ //不显式指定依赖库版本，表示每次都获取最新版本pod ‘AFNetworking’, ‘2.0’ //只使用2.0版本pod ‘AFNetworking’, ‘\\&gt;2.0′ //使用高于2.0的版本pod ‘AFNetworking’, ‘\\&gt;=2.0′ //使用大于或等于2.0的版本pod ‘AFNetworking’, ‘\\&lt;2.0′ //使用小于2.0的版本pod ‘AFNetworking’, ‘\\&lt;=2.0′ //使用小于或等于2.0的版本pod ‘AFNetworking’, ‘&gt;0.1.2′ //使用大于等于0.1.2但小于0.2的版本，相当于&gt;=0.1.2并且&lt;0.2.0pod ‘AFNetworking’, ‘&gt;0.1′ //使用大于等于0.1但小于1.0的版本pod ‘AFNetworking’, ‘&gt;0′ //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本","categories":[{"name":"技术","slug":"技术","permalink":"http://www.zhimakaiyuan.com/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"},{"name":"工具","slug":"工具","permalink":"http://www.zhimakaiyuan.com/tags/工具/"}]},{"title":"2015年终小结","slug":"2015年终小结","date":"2016-01-08T01:53:42.000Z","updated":"2016-12-14T02:47:16.000Z","comments":true,"path":"2016/01/08/2015年终小结/","link":"","permalink":"http://www.zhimakaiyuan.com/2016/01/08/2015年终小结/","excerpt":"2015年已近过去，掐指一算从2014年来公司实习到正式入职也已经一年多了，非常感谢公司对我的培养和实习导师对我的教导。","text":"2015年已近过去，掐指一算从2014年来公司实习到正式入职也已经一年多了，非常感谢公司对我的培养和实习导师对我的教导。工作至今，从最开始的小课桌，到安徽和教育，最云南，到现在的北京和教育，大大小小的项目也接触了五六个。在这一年的工作时间里，个人能力得到了很大的提升，虽不能完全独当一面但也能在大的项目中按照要求及时完成发放的任务，并即使处理反馈的各种问题单。希望在新的一年里个人能力能够更进一步，得到再一次的提升，迎接更加具有挑战性的工作。在这一年的时间里，接触最多的还是北京的项目。这是一项很锻炼人的项目，在项目里能够学到很多东西，掌握很多新的技能。希望在新的一年中，能够为项目做出更大的贡献，在任务不是很紧张的时候，能够学习新的技术，得以运用到工作中来。 #个人建议1、在任务比较宽松的时候多一些技术交流类似的活动，可以让大家了解并熟悉新的技术，得以运用到工作中来。2、使用团队协作工具，整个项目进度大家都能看到，让每个人更加合理规划自己的工作","categories":[{"name":"吐槽","slug":"吐槽","permalink":"http://www.zhimakaiyuan.com/categories/吐槽/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.zhimakaiyuan.com/tags/随笔/"},{"name":"碎碎念","slug":"碎碎念","permalink":"http://www.zhimakaiyuan.com/tags/碎碎念/"}]},{"title":"实现iOS 9 Task Switcher动画［转载］","slug":"实现iOS-9-Task-Switcher动画","date":"2015-09-08T07:04:13.000Z","updated":"2016-12-14T02:47:33.000Z","comments":true,"path":"2015/09/08/实现iOS-9-Task-Switcher动画/","link":"","permalink":"http://www.zhimakaiyuan.com/2015/09/08/实现iOS-9-Task-Switcher动画/","excerpt":"本文转载自http://tech.glowing.com/cn/如有侵犯，立马删除原文链接:实现iOS 9 Task Switcher动画 ##升级到iOS 9以后，发现新的task switcher的动画蛮有趣的，于是就动手实现了下，最终效果如下～","text":"本文转载自http://tech.glowing.com/cn/如有侵犯，立马删除原文链接:实现iOS 9 Task Switcher动画 ##升级到iOS 9以后，发现新的task switcher的动画蛮有趣的，于是就动手实现了下，最终效果如下～ 思路1 首先我们需要一个横向的scroll view，可以用UICollectionView，也可以自己实现一个。scroll view里每一页都是一张card，一屏5张card: 123｜ |｜card card card card card|｜ | 2 其次，我们需要在scrollViewDidScroll中判断每张card距离中心的距离，根据这个值来调整它的alpha，scale以及x轴的translation。 alpha：右边的card alpha都是1，左边的越靠左alpha越小scale： 从左往右依次变大translation：除了中间的card，所有的card都会右偏，而为了让中间card大部分都露出来，右边的card偏移需要比左边大开工 1. 横向滚动的scroll view我们可以自己实现一个横向无限滚动的scroll view, 具体可以参考:http://tech.glowing.com/cn/practice-in-uiscrollview/在scrollViewDidScroll中，我们提供一个delegate方法，告诉使用者每一页距离中心的位置，以便apply各种transform到这个view上，delegate方法如下： 123@protocol InfiniteScrollViewDelegate \\&lt;NSObject\\&gt;- (void)updateView:(UIView *)view withProgress:(CGFloat)progress scrollDirection:(ScrollDirection)direction;@end 说明一下progress的含义，如果一屏有5个visible views的话，那么它的值会从－2变化到2： 123| ||-2...-1...0...1...2|| | 2. 根据每一页的位置来设置它的transform首先是alpha，中心右边的card alpha都是1，而左边的会越来越淡，所以我们可以这样写： 12345if (progress \\&gt;= 0) view.alpha = 1;&#125; else view.alpha = 1 - fabs(progress) * 0.2;&#125; 其次是scale，由左往右依次变大： 123CGAffineTransform transform = CGAffineTransformIdentity; CGFloat scale = 1 + (progress) * 0.03; transform = CGAffineTransformScale(transform, scale, scale); 最后是x轴的translation，除了中间的card，所有的card都会往右偏，而为了让中间card大部分都露出来，右边的card偏移需要比左边大 1234567CGFloat translation = 0; if (progress \\&gt; 0) translation = fabs(progress) * SCREEN_WIDTH / 2.2;&#125; else translation = fabs(progress) * SCREEN_WIDTH / 15;&#125;transform = CGAffineTransformTranslate(transform, translation, 0); 完整的实现： 12345678910111213141516171819202122232425262728293031323334353637383940-(void)updateView:(UIView *)view withProgress:(CGFloat)progress scrollDirection:(ScrollDirection)direction&#123; // adjust z-index of each views NSMutableArray *views = [[self.scrollView allViews] mutableCopy]; [views sortUsingComparator:^NSComparisonResult(UIView *view1, UIView *view2) &#123; return view1.tag &gt; view2.tag; &#125;]; for (UIView *view in views) &#123; [view.superview bringSubviewToFront:view]; &#125;// alphaif (progress &gt;= 0) &#123; view.alpha = 1;&#125; else &#123; view.alpha = 1 - fabs(progress) * 0.2;&#125;CGAffineTransform transform = CGAffineTransformIdentity; // scaleCGFloat scale = 1 + (progress) * 0.03;transform = CGAffineTransformScale(transform, scale, scale);// translationCGFloat translation = 0;if (progress &gt; 0) &#123; translation = fabs(progress) * SCREEN_WIDTH / 2.2;&#125; else&#123; translation = fabs(progress) * SCREEN_WIDTH / 15;&#125;transform = CGAffineTransformTranslate(transform, translation, 0);view.transform = transform;&#125; 最后是完整的demo代码：https://github.com/Glow-Inc/TaskSwitcherDemo","categories":[{"name":"技术","slug":"技术","permalink":"http://www.zhimakaiyuan.com/categories/技术/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://www.zhimakaiyuan.com/tags/转载/"},{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"}]},{"title":"iOS多线程","slug":"iOS多线程","date":"2015-08-20T08:55:52.000Z","updated":"2016-12-14T02:48:04.000Z","comments":true,"path":"2015/08/20/iOS多线程/","link":"","permalink":"http://www.zhimakaiyuan.com/2015/08/20/iOS多线程/","excerpt":"iOS多线程分为四种 Pthreads NSThread GCD NSOperation &amp; NSOperationQueue","text":"iOS多线程分为四种 Pthreads NSThread GCD NSOperation &amp; NSOperationQueue Pthreads POSIX线程（POSIX threads），简称Pthreads，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。 简单地说，这是一套在很多操作系统上都通用的多线程API，所以移植性很强（然并卵），当然在 iOS 中也是可以的。不过这是基于C语言的框架，使用起来比较酸爽啦！感受一下： 123456789- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;pthread_t thread;//创建一个线程并自动执行pthread_create(&amp;thread, NULL, start, NULL);&#125;void *start(void *data) &#123;NSLog(@&quot;%@&quot;, [NSThread currentThread]);return NULL;&#125; 打印并输出：122015-07-27 23:57:21.689 testThread[10616:2644653] &lt;NSThread: 0x7fbb48d33690&gt;&#123;number = 2, name = (null)&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://www.zhimakaiyuan.com/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://www.zhimakaiyuan.com/tags/iOS/"}]},{"title":"NSCFString longValue","slug":"NSCFString-longValue","date":"2015-07-21T09:30:32.000Z","updated":"2016-12-14T02:48:14.000Z","comments":true,"path":"2015/07/21/NSCFString-longValue/","link":"","permalink":"http://www.zhimakaiyuan.com/2015/07/21/NSCFString-longValue/","excerpt":"昨天在写一个字典数据的时候，在一个字典内有18对键值对","text":"昨天在写一个字典数据的时候，在一个字典内有18对键值对其中有一个id的值为long型的,我就觉得既然你的值是long型的，那我要取你的值不是轻轻松松么,于是1long appID = [info[@&quot;id&quot;] longValue]; 然后当然报错了，12-[__NSCFString longValue]: unrecognized selector sent to instance 0x9bf8e10Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[__NSCFString longValue]: unrecognized selector sent to instance 0x9bf8e10&apos; 百思不得其解，不对啊，我之前用还是可以的，怎么就报错了呢。最后在stackoverflow上面找到了答案。原来，@“id”所对应得值，是一个id类型的值，我们需要先将他强制转换成NSString类型的值，然后再将NSString类型的值转化成long型的。 12NSString *strForId = dic[@&quot;id&quot;];long appID = [strForId longLongValue]; 或者直接强制转换1long appID ＝ （long)［dic[@\"id\"] longValue］; 果然再也不报错了～","categories":[{"name":"其他","slug":"其他","permalink":"http://www.zhimakaiyuan.com/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://www.zhimakaiyuan.com/tags/其他/"}]},{"title":"我的第一篇文章","slug":"我的第一篇文章","date":"2015-07-10T09:13:45.000Z","updated":"2016-12-14T02:47:47.000Z","comments":true,"path":"2015/07/10/我的第一篇文章/","link":"","permalink":"http://www.zhimakaiyuan.com/2015/07/10/我的第一篇文章/","excerpt":"","text":"#Hello World！好吧，暂且叫它我的第一篇吧，虽说起步晚，可是质量也不高啊。。。真不是一个用心的博主啊","categories":[{"name":"纪念","slug":"纪念","permalink":"http://www.zhimakaiyuan.com/categories/纪念/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.zhimakaiyuan.com/tags/随笔/"},{"name":"碎碎念","slug":"碎碎念","permalink":"http://www.zhimakaiyuan.com/tags/碎碎念/"}]}]}